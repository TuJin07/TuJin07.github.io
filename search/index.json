[{"content":"GitHub Pages 搭配 Hugo 搭建个人博客教程 前言 GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。\nGitHub Pages用于搭建一款轻量级的个人博客，相较于传统的服务端部署的建站服务，优势如下。\nGitHub Pages的基础功能是完全免费的，相较于服务端部署建站，你可能需要支付一笔高昂的云服务器费用以及购买域名的费用。 省略服务器部署的种种细节，由GitHub Pages代你完成，你只需要专注于文章内容的创作。 极高的自定义性以及拓展性，支持自定义你的网页模版、绑定你的域名、自带的HTTPS、各类插件支持等。 搭建 GitHub Pages 本教程默认你已经：\n拥有自己的GitHub账户，并有一定的GitHub使用经验。 本机上安装了Git，并知晓Git的简单使用。 熟悉一些命令行终端最基本的语法和操作（如 cd 等）。 创建个人页面仓库 登陆你的GitHub，在Github首页点击右上角的 + 号，点击 New repository 创建一个新仓库。出现如下页面。\n在 Repository name 内，以如下格式键入个人页面仓库名。\n1 {替换为你的GitHub昵称}.github.io 仓库类型设置为 Public，不需要添加 README，点击 create repository 创建仓库。\nGitHub Pages 配置 回到新建的仓库的首页，点击 Settings，点击 Pages 选项卡，进入 GitHub Pages 配置页面。在 Source 选项中选择 Deploy from a branch 选项。\n使用 Hugo 美化博客 接下来，我们会通过使用静态模板系统来让替代默认的网页模版，使得博客页面更加美观，同时文章也更易于管理。\n这里我们采用的基于Go编写的Hugo。除了Hugo之外，还有许多其他静态模板系统可以用来搭建 GitHub Pages。如GitHub官方推荐的Jekyll，采用Node.js编写的Hexo，采用Python编写的Pelican等。如果有你熟悉的静态模版系统，可以使用，而不必拘泥于教程中的Hugo或是官方推荐的Jekyll。\n以下安装教程基于macOS 13系统进行，Windows与Linux系统类似，有需要的朋友可以参考官方的中文文档 安装 Hugo。\nCommand Line Tools Command Line Tools 可以认为是一个可选的独立包，为macOS终端用户提供许多常用工具、实用程序和编译器。包括svn，git，make，GCC，clang，perl，size，strip，strings，libtool，cpp，what以及其他很多能够在Linux默认安装中找到的有用的命令。\n首先确保你的macOS上已经安装了终端的Command Line Tools工具，可以参考这篇文章。\nHomeBrew Homebrew是一款自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程。\n在终端运行如下命令，检验是否已安装 Brew。\n1 brew -v 如果你的系统已经安装 Brew 包管理器，可以跳至下一节。如提示指令找不到等错误信息，可以参考接下来的步骤进行 Brew 的安装。\n由于众所周知的原因，官网的安装脚本要么下载极慢，要么直接连接失败。在此，我们使用中科大的源来进行安装。\n1 /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)\u0026#34; 安装过程不需要任何操作，安装结束后如未设置环境变量路径，最后会有提示，根据提示要求，直接复制命令执行环境路径的添加即可。\n安装完成后再次使用上述指令检验，如提示版本信息则安装成功。\n1 2 % brew -v Homebrew 4.0.4 Hugo 安装 中科大源安装的 Brew 默认已经替换了镜像源，使用如下指令直接安装 Hugo，待安装完成即可。\n1 brew install hugo 使用 Hugo 进行初始化 在终端移动到你决定在本地存放你网站文件的目录下，执行以下命令，Hugo 会在当前目录下新建一个目录用于存放网站文件。\n1 hugo new site hugo-site hugo-stie 替换为你自己的网站名称，这个名称是任意的。\n使用 Hugo 模版 在Hugo Themes上你可以找到许多高质量的模版，同时作者也提供了安装的教程。\n一般而言，模版的安装过程都是大同小异的，这里我们以模版Tranquilpeek为例，说明下模版的使用方法。\n在终端中转到 Hugo 新建了网站的目录下，执行如下命令，clone主题的GitHub库至 ./themes/ 路径下。\n1 git clone https://github.com/kakawait/hugo-tranquilpeak-theme.git ./themes/ 然后移动到主题的根目录下，可以看到 exampleStie 目录。这是主题作者为我们准备的示例网站，建议在此基础上进行博客的搭建，可以省去很多不必要的麻烦。\n将 exampleStie 中的文件统一复制到网站的根目录下，同名时覆盖原有文件。完成后在终端移动至网站根目录下，运行如下命令，即可在本地查看网站渲染效果。\n1 hugo server 浏览器中输入地址 localhost:1313，跳转即可看到当前网站的渲染效果。此时看到的应该是模版的默认形式，我们没有添加任何修改的情况下。\n在此你可以自由点击各种选项卡进行测试。\n配置 Hugo 模版 这部分是较为重要的部分，让示例网站成为你的专属网站主要就是调整配置文件内的各项参数。\n模版的配置通常只需要通过根目录下的 config.toml 或 config.yaml 文件即可完成。需要注意的是二者是二选一的关系，除了语法没有其他差异，不要同时使用。\n在 config 文件内，你可以指定网站的域名、使用的主题、多语言设置、默认编码等，同时根据各个模版的不同，可以配置包括但不限于背景图片、头像、侧边栏功能、跳转链接等。具体可以参考每个主题作者提供的 config 示例和说明。\n在调整的过程中，可以保持网站的本地渲染状态，大多数情形下可以直接在页面上看到调整结果。\n将 Hugo 生成的静态模版发布至 GitHub Pages 使用以下指令，将网站声称一个静态文件。\n1 hugo 此时所有的网页信息都打包在了 public 文件夹下。\n接下来需要将GitHub的个人仓库衔接到本地的 public 文件夹。终端中移动到 public 目录中，执行以下指令，完成仓库的初次提交。\n1 2 3 4 5 git init git add . git commit -m \u0026#34;init\u0026#34; git remote add origin {你的github仓库链接} git push -u origin master 成功的话，所有的网站源码就已经托管在你的GitHub仓库上了，此时访问 https://{你的GitHub昵称}.github.io 就能访问部署的网站了。\n开始写作 可以使用以下命令生成文章草稿。\n1 hugo new posts/first-post.md 则在content目录中，会自动以 archetypes/default.md 为模板在 content/posts 目录下生成一篇名为 first-post.md 的文章草稿。这份草稿文件就是除开是个 MarkDown 文件外，还添加了标记文件信息的 front matter，格式如下。\n1 2 3 4 5 --- title: \u0026#34;First Post\u0026#34; date: 2022-11-25T15:23:42-08:00 draft: true --- 如图所示，默认的 front matter 中包含了文章名、日期与时间、是否草稿（设置为 false 后会在网页中展示）。除了上述几个必选的基本项外，你还可以添加其他标签方便你对文章进行管理，如 tags、categories 等。参见：Front Matter\n如上文所述，如果你想修改默认生成的 front matter，可以修改 archetypes/default.md 文件。\n通过这种形式，需要新建文章时，只需要重复一遍终端指令，输入对应的路径以及文件名即可生成 .md 文件。编辑文件内的 front matter 即可为文章指定标题、Tag等配置项。\n了解 Hugo 项目模版目录结构（可选） 参考：Hugo 不完美教程 - II: Hugo 目录组织\n成功运行模版的示例网站后，我们来了解下 hugo 网站根目录下的目录结构。\n1 2 3 4 5 6 7 8 . ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── static └── themes archetypes 默认内容模版。通过 hugo new 创建的内容会添加 date, title, draft = true 等扉页 front matter 设置信息，它们就是从 archetypes 模板文件中拷贝的。这可以节省时间，同时保证统一性。\ncontent 内容页面的存放目录，content下的一级子目录看作一个对应的 section 内容分类区。比如，为博客设置一个 blog 目录，为文章设置一个 articles 目录，为教程设置一个 tutorials 目录等，Hugo 使用内容分类区分作为默认内容类型 content type，如果在扉页 front matter 设置了 type 则以具体设置的类型为准。\n内容目录结构与 URL 对应关系参考如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 . └── content └── about | └── index.md // \u0026lt;- https://example.com/about/ ├── posts | ├── _index.md // \u0026lt;- https://example.com/posts/ | ├── index.md // \u0026lt;- https://example.com/posts/ | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ | ├── happy | | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ └── quote ├── first.md // \u0026lt;- https://example.com/quote/first/ └── second.md // \u0026lt;- https://example.com/quote/second/ data 数据模板目录，Hugo 静态网站不会连接像 MySQL 这样的数据库，而此目录保存的数据相当于 Hugo 使用的数据库，生成过程用到的配置数据，可以用 YAML, JSON, TOML 等格式文件。\nlayouts 布局模板文件目录，存放 .html 布局模板文件，对应不同的内容，模板有多种，data-templates、homepage、lists、menu-templates、partials、section-templates 等等。\n站点的首页模板在主题目录中 layouts/index.html，除首页外，Hugo 有两类基本页面：\nSingle page 单体页面，如 hugo new demo.md 创建的 Post 页面； List page 列表页面，如 tags 或 categories 页面； 这两种页面的默认模板都在主题目录中 layouts/_default，分别对应着 single.html 和 list.html。\nstatic 静态资源存放目录，比如想使用 Marmarid 画作模块，或者 jQuery 工具库，或者其它脚本、图像、CSS 等等，就可以将文件放到这里，在 Hugo 编译生成时会自动原样复制到 public 目录。注意，可以有多个静态资源目录。\npublic 生成静态站点的文件输出目录。\n结语 相信不少从事技术行业的朋友，在学习某项新技术的过程中，都曾受到一些技术文章、博客的帮助与启发。而自身也在或多或少地萌生过撰写文章或是博客来分享、记录知识的想法。笔者亦是如此，出于对知识的整理、巩固，以及期望自己的知识能帮助到更多有需要的人，笔者很早就尝试过搭建个人的博客笔记系统。\n最早，笔者是通过csdn、简书等技术内容分享平台进行文章发布与管理的，这类平台最大的优势就在于无需一些繁琐的配置，免费且开箱即用，只需要在平台创建上账号，即可专注于文章的创作，余下的网页部署、搜索引擎摘录这些工作都不需要操心。\n然而随着深入使用，这类平台的缺点变得愈发显著。首先，在平台上发布文章，始终是归属于该平台下，博客页面自定义程度受限、无法使用个人域名等缺陷不可避免；其次，该类平台往往出于业绩压力，某些方面的吃相愈发难看，渐渐地已经违背了知识分享这一初衷。\n为了克服上述缺点，同时自身的技术水平也有所长进，决定另辟蹊径，寻求一条能搭建完全独立的、由自己掌控的博客，且使用自己个性的域名的途径。期间采用的方案是云服务器部署加购买个人域名的方案。该方案从实用性的角度而言确实满足了我对它的所有需求，然而缺点也很明显，高昂的服务器费用缺也使得仍是学生的笔者感到难以维续。\n近期服务器即将到期，决定将博客系统继续迁徙至备受好评的GitHub Pages上。使用GitHub Pages作为一款轻量的个人博客服务，正如前面所说，它有着完全免费、无需购买云服务器从头搭建、主题海量、可以绑定域名等诸多优势。只是单纯作为一个记录与分享知识的平台而言，GitHub Pages仍可以说是中小型博客的最佳选项之一。\n也正如前文所说，希望我的文章能对你有所帮助。\n","date":"2023-03-02T16:02:30+08:00","image":"https://TuJin07.github.io/p/github-pages%E6%90%AD%E9%85%8Dhugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/cover_hua729ae8b5af9b293b0c75ca2c629cff2_3457944_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/github-pages%E6%90%AD%E9%85%8Dhugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","title":"GitHub Pages搭配Hugo搭建个人博客教程"},{"content":"Go语言中的反射机制，以及reflect包的一些基本使用 前言 Go语言是一门强类型语言，也就是说，在编写代码时，需要明确变量的类型。但是，有时候需要在运行时动态地获取或者修改变量的类型和值，这时候就需要用到反射机制。\n在Go语言中，反射机制可以让在运行时动态地获取和修改变量的类型和值。这种机制可以让编写更加灵活和通用的代码，因为不需要事先知道变量的类型，也不需要编写不同类型的处理函数。\nGo语言中的反射机制主要通过reflect包实现。在本文中，将介绍reflect包的一些基本功能和用法。\n基本功能 reflect包提供了许多函数和类型，可以让在运行时对变量进行反射操作。其中，最常用的函数是reflect.ValueOf()和reflect.TypeOf()，它们分别用于获取变量的值和类型。例如：\n1 2 3 var x int = 1 fmt.Println(reflect.TypeOf(x)) // 输出：int fmt.Println(reflect.ValueOf(x)) // 输出：1 除了获取变量的值和类型之外，reflect包还提供了一些其他的基本功能，例如：\n判断变量类型 可以使用reflect包提供的类型判断函数来判断变量的类型，例如：\n1 2 3 var x int = 1 var y float64 = 1.2 fmt.Println(reflect.TypeOf(x) == reflect.TypeOf(y)) // 输出：false 修改变量的值 通过reflect.ValueOf()函数获取变量的值之后，可以使用reflect包提供的一些方法来修改变量的值，例如：\n1 2 3 4 var x int = 1 value := reflect.ValueOf(\u0026amp;x) value.Elem().SetInt(2) fmt.Println(x) // 输出：2 获取结构体的所有成员并打印 可以使用reflect包提供的方法来获取结构体的所有成员并打印，遵循以下步骤：\n获取interface的reflect.Type，通过Type的到NumField，进行遍历。 遍历得到每个field的数据类型以及value。 通过field有一个Interface()方法可以得到对应的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { Name string Age int } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 25} inputValue := reflect.ValueOf(p) inputType := reflect.TypeOf(p) for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } } 输出结果为：\n1 2 Name: string = Alice Age: int = 25 获取类的方法并调用 可以使用reflect包提供的方法来获取类的方法并调用。首先，需要使用reflect.ValueOf()函数获取值信息，使用value.MethodByName()函数获取方法信息，最后使用method.Call()函数调用方法。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Person struct { Name string Age int } func (p Person) SayHello() { fmt.Println(\u0026#34;Hello, my name is\u0026#34;, p.Name) } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 25} value := reflect.ValueOf(p) method := value.MethodByName(\u0026#34;SayHello\u0026#34;) method.Call(nil) } 输出结果为：\n1 Hello, my name is Alice 方法带参数 如果类的方法有参数，使用method.Call()函数调用方法并传入参数。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { Name string Age int } func (p Person) SayHello(msg string) { fmt.Println(\u0026#34;Hello,\u0026#34;, msg, \u0026#34;, my name is\u0026#34;, p.Name) } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 25} value := reflect.ValueOf(p) method := value.MethodByName(\u0026#34;SayHello\u0026#34;) args := []reflect.Value{reflect.ValueOf(\u0026#34;world\u0026#34;)} method.Call(args) } 输出结果为：\n1 Hello, world, my name is Alice 方法带有返回值 如果类的方法有返回值，使用method.Call()函数调用方法并获取返回值。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { Name string Age int } func (p Person) GetAge() int { return p.Age } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 25} value := reflect.ValueOf(p) method := value.MethodByName(\u0026#34;GetAge\u0026#34;) result := method.Call(nil) fmt.Println(result[0].Int()) } 输出结果为：\n1 25 获取类的所有方法的信息 可以使用reflect包提供的方法获取类的所有方法并打印。使用reflect.TypeOf()函数获取类型信息，然后使用Type.NumMethod()函数获取方法数量，接着使用Type.Method()函数获取每个方法的信息，最后打印输出结果。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { Name string Age int } func (p Person) SayHello() { fmt.Println(\u0026#34;Hello, my name is\u0026#34;, p.Name) } func main() { p := Person{Name: \u0026#34;Alice\u0026#34;, Age: 25} t := reflect.TypeOf(p) for i := 0; i \u0026lt; t.NumMethod(); i++ { method := t.Method(i) fmt.Printf(\u0026#34;Name: %s, Type: %v\\n\u0026#34;, method.Name, method.Type) } } 输出结果为：\n1 Name: SayHello, Type: func(main.Person) 应用场景 反射机制在很多场景下都可以发挥重要作用，例如在编写通用代码时，经常需要编写一些可以处理不同类型数据的函数，这时候反射机制就可以派上用场。此外，在编写一些框架和库时，反射机制也是非常有用的，可以让代码更加灵活、简洁。\n例如，可以编写一个通用的JSON解析函数，该函数可以根据用户输入的数据类型，动态地解析JSON数据，并返回解析后的数据，这个函数非常灵活，可以处理很多不同类型的JSON数据。实现该函数的代码如下所示：\n1 2 3 4 5 6 7 8 func UnmarshalJSON(data []byte, v interface{}) error { value := reflect.ValueOf(v) if value.Kind() != reflect.Ptr || value.IsNil() { return errors.New(\u0026#34;UnmarshalJSON: v should be a pointer\u0026#34;) } return json.Unmarshal(data, v) } 总结 在本文中，介绍了Go语言中的反射机制，以及reflect包的一些基本功能和用法。反射机制可以让在运行时动态地获取和修改变量的类型和值，这种机制可以让编写更加灵活和通用的代码。同时，也讨论了反射机制的一些应用场景，例如在编写通用代码和框架时，反射机制可以发挥非常重要的作用。\n","date":"2023-02-09T17:42:47+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8Ereflect%E5%8C%85%E4%BD%BF%E7%94%A8/cover_hu195f0846ebef16ca4d598c982ae1c60d_2322831_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8Ereflect%E5%8C%85%E4%BD%BF%E7%94%A8/","title":"Golang中的反射机制与reflect包使用"},{"content":"Go语言中的空接口类型和类型断言机制 介绍 Go语言是一种静态类型语言，每个类型都有它自己的方法集。然而，有时候需要一个通用的类型，可以接受任意类型的值。这就是空接口类型的作用。空接口类型可以保存任何类型的值，因此可以使用它来创建通用的函数和数据结构。在本文中，将探讨空接口类型以及类型断言机制。\n空接口类型 空接口类型是一个不包含任何方法的接口类型。在Go语言中，空接口类型被定义为interface{}。空接口类型可以保存任何类型的值，因此可以使用它来创建通用的函数和数据结构。例如，可以使用空接口类型来创建一个可以接受任何类型的函数参数：\n1 2 3 func printType(i interface{}) { fmt.Printf(\u0026#34;Type: %T\\\\\\\\n\u0026#34;, i) } 在这个例子中，参数i的类型是空接口类型，可以接受任何类型的值。函数printType将打印出参数i的类型。\n空接口类型是Go语言中非常重要的一个特性。使用空接口类型，可以创建通用的函数和数据结构。例如，可以使用空接口类型来实现一个类似于Python中list的数据结构：\n1 2 3 4 5 6 7 8 9 type List []interface{} func (l *List) Append(item interface{}) { *l = append(*l, item) } func (l *List) Remove(index int) { *l = append((*l)[:index], (*l)[index+1:]...) } 在这个例子中，定义了一个List类型，它是一个空接口类型的切片。还定义了Append和Remove方法，可以向List中添加和删除任何类型的值。\n类型断言 类型断言是指将接口类型转换为另一个类型的过程。在Go语言中，类型断言有两种形式：类型断言表达式和类型断言语句。\n类型断言表达式 类型断言表达式的一般形式为：\n1 value, ok := interface_variable.(type) 其中，interface_variable是一个接口类型的变量，value是一个指定类型的变量，ok是一个bool类型的结果。如果interface_variable包含一个指定类型的值，那么value将保存这个值，ok将为true。否则，value将为指定类型的零值，ok将为false。\n例如，可以使用类型断言表达式来判断一个空接口类型的值是否为一个字符串类型：\n1 2 3 4 5 6 7 func printString(i interface{}) { if s, ok := i.(string); ok { fmt.Println(s) } else { fmt.Println(\u0026#34;Not a string\u0026#34;) } } 在这个例子中，函数printString将打印出参数i的值，如果它是一个字符串类型的值，否则打印出\u0026quot;Not a string\u0026quot;。\n类型断言语句 类型断言语句的一般形式为：\n1 value := interface_variable.(type) 其中，interface_variable是一个接口类型的变量，value是一个指定类型的变量。如果interface_variable包含一个指定类型的值，那么value将保存这个值。否则，将会产生一个运行时错误。\n结论 空接口类型和类型断言机制是Go语言中非常重要的特性。使用空接口类型和类型断言，可以创建通用的函数和数据结构。同时，类型断言也是Go语言中类型安全的重要保证。\n","date":"2023-02-09T16:01:39+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/cover_hu501226a2bc4a376d7d6adacfa57f9122_4636637_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/","title":"Golang中的空接口与类型断言"},{"content":"Go语言中面向对象类的创建，封装，继承以及多态 前言 Go语言是一门静态类型的编程语言，具有高效、简洁、安全等特性，广泛应用于网络编程、云计算、分布式系统等领域。虽然Go语言是以“接口(interface)”而不是以“类(class)”为基础的面向对象编程范式，但是Go语言中也可以使用结构体(struct)来实现类的相关功能。\n创建类 Go语言中的类可以通过结构体实现，结构体中可以包含字段和方法。字段可用于存储数据，方法可用于对数据进行操作。下面是一个简单的例子：\n1 2 3 4 5 6 7 8 type Person struct { name string age int } func (p Person) SayHello() { fmt.Printf(\u0026#34;Hello, my name is %s, I\u0026#39;m %d years old.\\\\\\\\n\u0026#34;, p.name, p.age) } 如上例子中，定义了一个名为“Person”的结构体，包含了“name”和“age”两个字段，以及一个名为“SayHello”的方法。方法的定义中，使用了“func (p Person)”的形式，表示方法“SayHello”是“Person”类型的方法，即“Person”类的方法。\n类的方法 方法是与类型相关联的函数，可用于对类型进行操作。方法可以定义在值类型或指针类型上，两种类型的方法行为有所不同。\n值方法 值方法是指定义在值类型上的方法。值类型是指包含实际数据的类型，如int、float、struct等。在值方法中，方法接收者是值类型的实例，方法中对实例的修改只影响到当前方法中的实例，不影响原始实例。下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Person struct { name string age int } func (p Person) SayHello() { fmt.Printf(\u0026#34;Hello, my name is %s, I\u0026#39;m %d years old.\\\\\\\\\\\\\\\\n\u0026#34;, p.name, p.age) } func main() { person := Person{name: \u0026#34;Tom\u0026#34;, age: 18} person.SayHello() } 如上例子中，定义了一个名为“Person”的结构体，包含了“name”和“age”两个字段，以及一个名为“SayHello”的值方法。在main函数中，创建了一个名为“person”的“Person”类型的实例，并调用了该实例的“SayHello”方法。\n指针方法 指针方法是指定义在指针类型上的方法。指针类型是指包含实际数据指针的类型，如*int、*float、*struct等。在指针方法中，方法接收者是指针类型的实例，方法中对实例的修改会影响到原始实例。下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Person struct { name string age int } func (p *Person) SetName(name string) { p.name = name } func main() { person := \u0026amp;Person{name: \u0026#34;Tom\u0026#34;, age: 18} person.SetName(\u0026#34;Jerry\u0026#34;) fmt.Println(person.name) } 如上例子中，定义了一个名为“Person”的结构体，包含了“name”和“age”两个字段，以及一个名为“SetName”的指针方法。在main函数中，创建了一个名为“person”的“Person”类型的指针，并调用了该指针的“SetName”方法，将“name”字段的值修改为“Jerry”。\n值方法与指针方法的区别 值方法和指针方法的区别在于，值方法中对实例的修改只影响到当前方法中的实例，不影响原始实例；而指针方法中对实例的修改会影响到原始实例。在使用方法时，需要根据具体情况来选择使用值方法还是指针方法。\n如果方法中不需要修改实例的值，或者实例是一个较小的结构体，可以使用值方法；如果方法中需要修改实例的值，或者实例是一个较大的结构体，可以使用指针方法。另外，如果方法中需要修改实例的值，但是实例是一个常量或字面量，只能使用值方法。\n封装 封装是面向对象编程的一个重要特性，可以将类的实现细节隐藏起来，只暴露必要的接口。在Go语言中，可以使用大小写来控制字段和方法的可见性。首字母大写的字段和方法是公开的，可以被其他包访问；首字母小写的字段和方法是私有的，只能在当前包内访问。下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Person struct { name string age int } func (p Person) SayHello() { fmt.Printf(\u0026#34;Hello, my name is %s, I\u0026#39;m %d years old.\\\\\\\\n\u0026#34;, p.name, p.age) } func (p Person) SetName(name string) { p.name = name } func (p Person) GetName() string { return p.name } 如上例子中，增加了两个方法“SetName”和“GetName”，用于设置和获取“name”字段的值。这两个方法都是“Person”类的方法，但是“SetName”方法的首字母是大写的，可以被其他包访问；“GetName”方法的首字母是小写的，只能在当前包内访问。\n继承 继承是面向对象编程的另一个重要特性，它允许一个类继承另一个类的属性和方法。在Go语言中，可以使用嵌入结构体的方式来实现继承。嵌入结构体是指在一个结构体中嵌入另一个结构体，被嵌入的结构体也称为“匿名结构体”。下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { name string age int } func (p Person) SayHello() { fmt.Printf(\u0026#34;Hello, my name is %s, I\u0026#39;m %d years old.\\\\\\\\n\u0026#34;, p.name, p.age) } type Student struct { Person school string } func (s Student) Study() { fmt.Printf(\u0026#34;I\u0026#39;m studying at %s.\\\\\\\\n\u0026#34;, s.school) } 如上例子中，定义了一个名为“Student”的结构体，它嵌入了“Person”结构体，表示“Student”类继承了“Person”类的属性和方法。同时，“Student”类还增加了一个“school”字段和一个“Study”方法，用于表示学校和学习。\n定义一个子类对象 创建子类的对象可以通过嵌套结构体的方式实现，例如：\n1 2 3 4 func main() { student := Student{Person{name: \u0026#34;Tom\u0026#34;, age: 18}, \u0026#34;MIT\u0026#34;} student.Study() } 访问父类的方法 如上例子中，可以通过“Student”类型的实例来访问“Person”类型的属性和方法，例如：\n1 2 3 4 func main() { student := Student{Person{name: \u0026#34;Tom\u0026#34;, age: 18}, \u0026#34;MIT\u0026#34;} student.SayHello() } 此外，还可以通过重写父类的方法来实现多态。重写父类方法的方式和其他语言类似，只需要在子类中定义同名的方法即可。在调用方法时，会根据实例的类型调用对应的方法。实际使用中，更常用的实现多态的方式是下文会提出的通过接口实现多态的方式。\n重写父类的方法 重写父类的方法可以使用与其他语言类似的方式，在子类中定义同名的方法即可。在调用方法时，会根据实例的类型调用对应的方法。如果子类中没有定义同名的方法，则会调用父类的方法。在调用父类的方法时，可以使用“父类类型.方法名”的方式进行调用。\n如上例子中，可以定义一个“Teacher”类，继承“Person”类的属性和方法，同时重写“SayHello”方法，输出“教师”信息。例如：\n1 2 3 4 5 6 7 8 type Teacher struct { Person subject string } func (t Teacher) SayHello() { fmt.Printf(\u0026#34;Hello, I\u0026#39;m a teacher. My name is %s, I teach %s.\\\\\\\\\\\\\\\\n\u0026#34;, t.name, t.subject) } 如上例子中，定义了一个名为“Teacher”的结构体，嵌入了“Person”结构体，表示“Teacher”类继承了“Person”类的属性和方法。“Teacher”类还增加了一个“subject”字段和一个重写了“SayHello”方法。\n继承的限制 虽然嵌入结构体可以实现类的继承，但是在Go语言中并不支持多重继承，即一个类不能同时继承多个类。这是因为多重继承容易造成代码混乱和不可预测的行为，而Go语言强调的是清晰、简洁和可读性强的代码风格。\n此外，嵌入结构体也有一些需要注意的地方。由于嵌入结构体是通过复制字段和方法实现的，因此在多重嵌套的情况下，可能会出现同名的字段和方法，从而导致不可预测的行为。为了避免这种情况，可以使用别名来区分同名的字段和方法。\n多态 多态是面向对象编程的另一个重要特性，它允许不同的对象对同一个消息做出不同的响应。在Go语言中，可以使用**接口(interface)**来实现多态。接口是一组方法的集合，不包含任何字段。**一个类型只要实现了接口中定义的所有方法，就可以被认为是该接口类型的实例。**下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Animal interface { Speak() string } type Cat struct { name string } func (c Cat) Speak() string { return \u0026#34;Meow\u0026#34; } type Dog struct { name string } func (d Dog) Speak() string { return \u0026#34;Woof\u0026#34; } func main() { animals := []Animal{Cat{name: \u0026#34;Tom\u0026#34;}, Dog{name: \u0026#34;Jerry\u0026#34;}} for _, animal := range animals { fmt.Println(animal.Speak()) } } 如上例子中，定义了一个名为“Animal”的接口，包含一个名为“Speak”的方法。然后定义了“Cat”和“Dog”两个结构体，它们都实现了“Animal”接口的“Speak”方法。最后创建了一个“animals”数组，将“Cat”和“Dog”实例放入其中，然后遍历数组，调用“Speak”方法输出不同的声音。\n结论 Go语言虽然不是以“类”为基础的面向对象编程语言，但是它仍然支持类的相关功能，包括封装、继承和多态。通过结构体、大小写控制、嵌入结构体和接口等方式，可以实现面向对象编程的各种特性，从而更好地编写高效、简洁、安全的代码。\n","date":"2023-01-09T15:13:35+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/cover_hudbc4139352dfb2ed4c2bf87baa19b221_2881103_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"Golang中的面向对象"},{"content":"Go语言中进行错误处理 Go语言提供了一种简单、清晰、有效的错误处理机制，可以帮助开发者更好地处理程序中可能出现的错误。本文将介绍Go语言中的错误处理机制，包括错误类型、错误处理方式、错误传递等内容。\n在 Go 语言中，错误是可以预期的，并且不是非常严重，不会影响程序的运行。对于这类问题，可以用返回错误给调用者的方法，让调用者自己决定如何处理。这一点区别于panic。\n错误类型 在Go语言中，错误类型是一个内置的接口类型，定义如下：\n1 2 3 type error interface { Error() string } 任何实现了这个接口的类型都可以作为错误类型。\n实现接口并自定义错误类型 可以定义一个自定义的错误类型，实现上述的接口，并用来表示特定的错误，例如：\n1 2 3 4 5 6 7 8 type MyError struct { ErrCode int ErrMsg string } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;error code: %d, error message: %s\u0026#34;, e.ErrCode, e.ErrMsg) } 在这个例子中，定义了一个自定义的错误类型MyError，并实现了error接口中的Error()方法，用来返回错误信息。这样就可以通过返回这个自定义的错误类型来表示程序中可能出现的错误。\n自定义错误类方式往往会存在错误嵌套，要尽量减少不必要的包裹。以免造成错误链过长，影响性能。\n通过Go提供的方法直接创建error 通过Error.New()的形式创建一个error。errors.New()方法中，先是实例化了一个errorString的结构体，并且取其指针地址返回。返回指针，不是返回结构体对象本身是为了避免定义两个同样错误内容的不同自定义错误做“==”判定的时候会相等，但是指针的话，就是比较两个不一样的地址，就不会相等。\n1 2 3 4 5 // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } 错误处理方式 在Go语言中，通常使用多返回值来表示函数执行的结果和可能出现的错误。如果函数执行成功，第二个返回值返回一个nil值，否则返回一个错误类型。例如：\n1 2 3 4 5 6 func divide(a, b int) (int, error) { if b == 0 { return 0, \u0026amp;MyError{ErrCode: 1001, ErrMsg: \u0026#34;division by zero\u0026#34;} } return a / b, nil } 这个例子中，定义了一个divide函数，用来计算a除以b的结果。如果b为0，则返回一个自定义的错误类型MyError，否则返回a/b的结果和一个nil值。\n调用函数时，通常会检查返回的错误值，如果不为nil，则表示函数执行失败。例如：\n1 2 3 4 5 6 result, err := divide(10, 0) if err != nil { fmt.Println(err) } else { fmt.Println(result) } 调用divide函数计算10除以0的结果，由于b为0，函数会返回一个自定义的错误类型MyError。检查返回的错误值，发现不为nil，则输出错误信息。\n错误类型可以是一个nil指针。这意味着函数执行成功，没有发生任何错误。因此，我们在检查错误值时需要判断它是否为nil。\n当发生错误情况时，应该只做一件事情：能够处理就处理，不能处理应该向上返回。不应该导出打日志同时又把错误向上返回。处理完后，错误不再是错误，返回的err应该是nil。\n总结 Go语言提供了一种简单、清晰、有效的错误处理机制，可以帮助开发者更好地处理程序中可能出现的错误。错误类型是一个内置的接口类型，通常通过自定义的错误类型来表示特定的错误。在函数执行时，通常使用返回值来表示函数执行的结果和可能出现的错误。\n参考 go中的err!=nil好烦？教你怎么优雅地处理error\n","date":"2023-01-07T22:17:33+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/cover_huf5e4da75d2dea8f121fbfe6c692afb96_4903664_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","title":"Golang中的错误处理"},{"content":"Go语言中panic，recover以及异常处理 常处理可以帮助我们处理程序中出现的各种错误，比如文件读写错误、网络连接错误等。在Go语言中，可以使用defer和recover关键字来处理异常，本文意在详细介绍如何在defer中通过recover捕获异常并进行处理。\nGo 语言把真正的异常叫做 panic，是指出现重大错误，比如数组越界之类的编程BUG或者是那些需要人工介入才能修复的问题，比如程序启动时加载资源出错等等。区别于Go中提供的错误处理。\n老爷子的原话：When you panic in Go, you’re freaking out, it’s not someone elses problem, it’s game over man.\ndefer关键字和panic()函数 在Go语言中，通过panic函数可以引发一个运行时错误，类似于Java中的异常。当程序遇到panic时，会停止当前函数的执行并向上返回，直到程序崩溃或被recover捕获。\ndefer关键字用于在函数返回前执行一些收尾工作，比如关闭文件或释放资源等。defer语句可以在函数内部的任何位置定义，并且可以定义多个defer语句。当函数执行完毕时，defer语句会按照后进先出的顺序执行。\nrecover()函数的使用 recover是一个内置函数，用于捕获panic引起的异常。在函数内部通过defer关键字调用recover函数，可以捕获异常并进行处理。\n下面是一个示例代码：\n1 2 3 4 5 6 7 8 func main() { defer func() { if err := recover(); err != nil { fmt.Println(\u0026#34;recover from:\u0026#34;, err) } }() panic(\u0026#34;error\u0026#34;) } 这个例子中，通过defer关键字定义了一个匿名函数，并在其中调用了recover函数。当程序执行到panic函数时，会引发一个异常，并停止当前函数的执行。然后，程序会执行defer语句中定义的函数，并调用recover函数。如果recover函数返回一个非nil值，说明程序遇到了panic，并且返回值就是panic函数中传递的参数。在这个例子中，recover函数返回了字符串\u0026quot;error\u0026quot;，代表程序遇到了一个错误。实际开发中，可以根据不同的错误信息来进行相应的处理。\nrecover函数只有在defer语句中调用才有效。如果在函数之外调用recover函数，会返回nil值且不会捕获panic。\n实际开发中，我们通常会将defer关键字和recover函数组合使用，来捕获程序中可能出现的异常并进行处理。\n下面是另一个示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func divide(a, b int) { defer func() { if err := recover(); err != nil { fmt.Println(\u0026#34;recover from:\u0026#34;, err) } }() if b == 0 { panic(\u0026#34;division by zero\u0026#34;) } fmt.Println(a / b) } func main() { divide(1, 0) } 在这个例子中，定义了一个divide函数，用来计算两个数的商。在函数内部，如果除数为0，就会引发一个异常并停止当前函数的执行。然后，程序会执行defer语句中定义的匿名函数，并调用recover函数。如果recover函数返回一个非nil值，说明程序遇到了异常，并且可以根据这个异常信息来进行相应的处理。在这个例子中，我们会输出字符串\u0026quot;division by zero\u0026quot;，代表程序遇到了除以0的错误。\n如果程序遇到了多个panic，只有最后一个panic才会被recover捕获。\n实际应用 在实际开发中，defer和recover可以用于很多场景，比如：\n在使用锁时，如果锁没有被释放，就会导致死锁。可以在defer语句中释放锁，来避免忘记释放锁、或是出现panic时没有执行释放锁而导致死锁。 在打开文件后使用defer语句关闭文件，同样可以避免忘记关闭文件或是出现panic时没有执行关闭而导致的资源泄漏。 在数据库操作中，如果出现异常，在defer语句中回滚事务，避免数据不一致的情况发生。 总结 Go语言中，通过defer和recover关键字，可以很方便地捕获程序中可能出现的异常并进行处理。当程序遇到panic时，会停止当前函数的执行并向上返回，直到程序崩溃或被recover捕获。在函数内部通过defer关键字调用recover函数，来捕获异常并进行处理。在实际开发中，会将defer和recover关键字组合使用，来处理可能出现的异常。\n关于Go中的error和panic在实际开发如何选用 一个个人认为比较兼顾代码规范性和实用性的方式：“不应该按严重性来分error或panic，而是按处理方式来区分—— 出错后上层有可能走另外一个（正常）分支的情况，用error；出错后除了记录和统一处理（例如通知用户）之外，基本上没其他处理方式，则用panic。换言之，java的checked exception和runtime exception是更正确的抽象。”\n","date":"2023-01-07T21:32:54+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84panicrecover%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/cover_huaf823ab1439e138cdecdfdf1e26f4f2e_6426320_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84panicrecover%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"Golang中的panic，recover以及异常处理"},{"content":"Go语言中的defer关键字 在Go语言中，defer是一个非常有用的关键字，可以用于在函数结束前执行某个语句或函数调用。它可以用来处理一些收尾工作，比如关闭文件、释放资源等。本文将介绍defer的使用方法和注意事项，并给出一些实例便于读者更好地理解它。\ndefer的基本用法 defer语句的语法格式为“defer 函数名()”或“defer 语句”。当函数执行到defer语句时，不会立即执行，而是先将defer语句压入栈中，等到函数执行完毕后再依次执行栈中的defer语句。下面是一个简单的例子：\n1 2 3 4 func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } 执行结果为“hello”和“world”，因为defer语句被压入栈中，等到函数结束前才会被执行。可以看出，defer语句的执行顺序是“后进先出”，即最后一个defer语句最先执行，第一个defer语句最后执行。\ndefer的注意事项 在使用defer语句时需要注意以下几点：\n如前文所说，defer语句的执行顺序是“后进先出”，即最后一个defer语句最先执行，第一个defer语句最后执行。 如果在defer语句中调用了函数或方法并传递了参数，那么参数会在defer语句执行时被计算，而不是在函数调用时被计算。例如： 1 2 3 4 5 6 func main() { a := 1 defer fmt.Println(a) a = 2 fmt.Println(a) } 执行结果为先打印“2”，再打印出“1”。因为defer语句中的参数在defer语句执行时被计算，此时变量a的值仍为“1”，而不是在函数调用时被计算。\n如果在函数中使用了return语句，并且在return语句前调用了defer语句，那么defer语句会在return语句执行前被执行。例如： 1 2 3 4 5 6 7 8 func main() { fmt.Println(test()) } func test() int { defer fmt.Println(\u0026#34;defer\u0026#34;) return 1 } 执行结果为先打印“defer”，后打印“1”。\n如果在defer语句中发生了panic，那么在函数返回前会先执行所有的defer语句，然后再把panic传递给调用者。这一点特性可以用来进行异常处理。 实例 下面是一个使用defer语句的实例，用来统计函数的执行时间：\n1 2 3 4 5 6 7 func main() { start := time.Now() defer func() { fmt.Println(\u0026#34;elapsed time:\u0026#34;, time.Since(start)) }() // do something... } 在这个例子中，我们使用time包来获取函数的开始时间，然后使用defer语句在函数结束时输出函数的执行时间。这样可以方便地统计函数的执行时间。\n除了用于统计函数的执行时间，defer语句还可以用于一些其他场景。比如，在打开文件后使用defer语句关闭文件，可以避免忘记关闭文件而导致资源泄漏。又比如，在使用锁时，使用defer语句释放锁可以避免忘记释放锁而导致死锁等问题。\n总结 Go语言中的defer语句是一个非常有用的关键字，可以用于在函数结束前执行某个语句或函数调用。其执行顺序是“后进先出”，并且可以用于在函数中处理一些收尾工作。在使用defer语句时，如前文的注意事项所言，在defer语句中调用函数或方法并传递参数时，需要注意参数的计算时机。此外，如果在函数中使用了return语句并且在return语句中调用了defer语句，那么defer语句会在return语句执行前被执行。\n","date":"2023-01-07T21:32:34+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84defer%E5%85%B3%E9%94%AE%E5%AD%97/cover_hu1e01195895d88f60db6ceda6ffe70854_2107158_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84defer%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Golang中的defer关键字"},{"content":"Go语言中的main函数与init函数 前言 Go语言中有两个比较重要的函数：main()和init()。这两个函数在程序运行时都会被自动调用，但它们的调用时机和作用却不尽相同。本文将探讨这两个函数的异同点以及各自的使用场景。\nmain函数 main()函数是Go程序的入口函数，它是程序运行时的起点。无论是执行可执行文件还是运行源代码，都需要首先找到main()函数。在main()函数中，我们可以编写程序的逻辑代码，定义变量，调用函数等。当main()函数执行完毕后，程序将会退出。\n以下是一个简单的main()函数示例：\n1 2 3 func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 在上述代码中，我们调用了fmt包中的Println()函数，用于向控制台输出一句话“Hello, World!”。\n在实际编程中，和其他所有的语言一样，我们需要根据实际需求编写main()函数中的逻辑代码，以便完成程序的功能。\ninit函数 init()函数是Go语言中的一个特殊函数，它与main()函数有着明显的不同。init()函数是在程序启动时自动执行的，它没有参数和返回值。它的作用是在程序运行前做一些准备工作。init()函数可以定义在任何包中，且可以定义多个，而main()函数只能定义在main包中，且只能定义一个。\n以下是一个简单的init()函数示例：\n1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;Initializing...\u0026#34;) } 在上述代码中，我们在main包中定义了一个init()函数，该函数在程序启动时将会被自动调用，并输出一句话“Initializing\u0026hellip;”。\ninit()函数是在程序启动时自动调用的函数。当运行一个Go程序时并导入所使用的包时，程序会自动寻找并调用所有导入的包中定义好的init()函数。init()函数可以用于初始化一些变量，打开数据库连接，注册HTTP服务等。\n两者的执行顺序 通过一张图可以形象地表达当Go程序执行时，main()函数和init()函数的执行顺序。来源：函数\n总结 init()和main()函数是Go中的两个保留函数。一般而言，init()函数在包被导入的同时执行，通常在包常量和包变量定义之后用于执行初始化工作。而main()函数是程序的入口点，负责实现程序逻辑。这是二者最根本的区别。\n其它一些形式上的区别如下所列出。\nmain()函数是程序的入口函数，而init()函数是在程序启动时自动调用的函数。 main()函数只能定义在main包中，而init()函数可以定义在任何包中。 一个Go程序只能有一个main()函数，但可以有多个init()函数。 ","date":"2023-01-07T20:27:48+08:00","image":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BF%9D%E7%95%99%E5%87%BD%E6%95%B0-main%E5%92%8Cinit/cover_huf84a865dcd25109466bd72dbc5ea937a_2328634_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/golang%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BF%9D%E7%95%99%E5%87%BD%E6%95%B0-main%E5%92%8Cinit/","title":"Golang中的两个保留函数: main()和init()"},{"content":"基于消息队列实现的分布式随机信号分析系统 功能要求 利用 MOM 消息队列技术实现一个分布式随机信号分析系统，具体要求：\n随机信号产生器微服务：每隔100ms左右生成一个正态分布的随机数字，并作为一个消息发布。 随机信号统计分析微服务：对信号进行如下分析。 计算过去 N 个随机信号的均值与方差（N 为常量，可设置）。 计算所有历史数据中的最大值与最小值。 定时地将分析结果打包成一个新消息并通过 MOM 发布出去。 实时数据显示微服务： 实时绘制过去一段时间内的随机信号的折线图。 实时显示随机信号统计分析结果。 设计说明 项目技术栈 项目架构：Java SpringBoot\nMessageQueue 中间件：kafka\n图表生成：xchart\n项目结构图 说明：\nserver 完成微服务的核心功能。package server 下包含 3 个实现类。\nRandomSignalGenerator：随机信号发生器，可以指定 u 与 b，实现满足不同正态分布的随机信号发生。 RandomSignalAnalyzer：随机信号分析器，捕获并分析随机信号，获取最大最小值、平均值、方差等。 DataDisplay：数据显示器，将过去一段时间最多 N 个随机信号在坐标系上用折线图显示，以及显示最值、均值、方差等。 server 与 Message Queue 的交互通过中间层 controller 来间接完成。\nMessage Queue 下含两个 topic，分别为 RandomSignal 与 DisplayDate，分别用于发布正态分布随机信号与信号分析结果，主题的发布与订阅关系如图所示。\n此外，程序中还包含类 data.DataRecord，用于存储信号分析结果，作为消息发布的一个存储单元。接口实现类 serializer.DataRecordSerializer 与 serializer.DataRecordDeserializer，用于 data.DataRecord 的序列化与反序列化工作。\n程序运行测试 安装 JDK 网上已经有很多此类文章，略过，本文中所用 JDK 版本为 1.8 。\n安装配置 kafka 参考网上其他文章，略。\n启动 kafka 内置的 zookeeper 移动至 kafka 的安装目录下，通过命令启动 kafka 的前置程序 zookeeper。\n1 .\\bin\\windows\\zookeeper-server-start.bat .\\config\\zookeeper.properties 启动后保留窗口，不要关闭。\n启动 kafka 服务 通过命令启动 kafka 服务。\n1 .\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties 启动后保留窗口。\n运行微服务 依次启动 Java 程序 GeneratorController，AnalyzerController，DisplayController。待程序成功启动后，会弹出信号捕获窗口，实时动态显示并更新随机信号分析值。\nN=500 ，u=0，b=1 的标准正态分布随机信号 折线图：\n属性值打印：\nN=500，u=10，b=16 的正态分布随机信号 折线图：\n属性值打印：\n源程序 AnalyzerController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import com.example.messagequeuehomework.data.DataRecord; import com.example.messagequeuehomework.server.RandomSignalAnalyzer; import org.apache.kafka.clients.consumer.Consumer; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.Producer; import org.apache.kafka.clients.producer.ProducerRecord; import java.time.Duration; import java.util.Collections; import java.util.Properties; public class AnalyzerController { private static final int N = 500; public static void main(String[] args) { // 消费 GeneratorController 生成的消息，绑定主题 \u0026#34;RandomSignal\u0026#34; Properties props = new Properties(); props.put(\u0026#34;bootstrap.servers\u0026#34;, \u0026#34;localhost:9092\u0026#34;); props.put(\u0026#34;group.id\u0026#34;, \u0026#34;MyConsumer\u0026#34;); props.put(\u0026#34;enable.auto.commit\u0026#34;, \u0026#34;true\u0026#34;); props.put(\u0026#34;key.deserializer\u0026#34;, \u0026#34;org.apache.kafka.common.serialization.IntegerDeserializer\u0026#34;); props.put(\u0026#34;value.deserializer\u0026#34;, \u0026#34;org.apache.kafka.common.serialization.DoubleDeserializer\u0026#34;); Consumer\u0026lt;Integer, Double\u0026gt; consumer = new KafkaConsumer\u0026lt;\u0026gt;(props); consumer.subscribe(Collections.singletonList(\u0026#34;RandomSignal\u0026#34;)); // 生成供 DisplayController 消费的消息，绑定主题 \u0026#34;DisplayData\u0026#34; props = new Properties(); props.put(\u0026#34;bootstrap.servers\u0026#34;, \u0026#34;localhost:9092\u0026#34;); props.put(\u0026#34;key.serializer\u0026#34;, \u0026#34;org.apache.kafka.common.serialization.IntegerSerializer\u0026#34;); props.put(\u0026#34;value.serializer\u0026#34;, \u0026#34;com.example.messagequeuehomework.serializer.DataRecordSerializer\u0026#34;); Producer\u0026lt;Integer, DataRecord\u0026gt; producer = new KafkaProducer\u0026lt;\u0026gt;(props); int key = 0; RandomSignalAnalyzer analyzer = new RandomSignalAnalyzer(N); while (true) { // 接收 RandomSignal 的消息并进行分析 ConsumerRecords\u0026lt;Integer, Double\u0026gt; records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord\u0026lt;Integer, Double\u0026gt; record : records) { analyzer.addNext(record.value()); // 分析结果发布到主题 DisplayData if (analyzer.getSize() != 0) { // System.out.println(\u0026#34;Analyzer 消息接收\u0026#34;); producer.send( new ProducerRecord\u0026lt;\u0026gt;(\u0026#34;DisplayData\u0026#34;, key++, new DataRecord( N, analyzer.getMaxi(), analyzer.getMini(), analyzer.getAverage(), analyzer.getVariance(), analyzer.getLast() )) ); } } } } } DisplayContoller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import com.example.messagequeuehomework.data.DataRecord; import com.example.messagequeuehomework.server.DataDisplay; import org.apache.kafka.clients.consumer.Consumer; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import java.time.Duration; import java.util.Collections; import java.util.Properties; public class DisplayController { public static void main(String[] args) { // 消费 AnalyzerController 生成的消息，绑定主题 \u0026#34;DisplayData\u0026#34; Properties props = new Properties(); props.put(\u0026#34;bootstrap.servers\u0026#34;, \u0026#34;localhost:9092\u0026#34;); props.put(\u0026#34;group.id\u0026#34;, \u0026#34;MyConsumer\u0026#34;); props.put(\u0026#34;enable.auto.commit\u0026#34;, \u0026#34;true\u0026#34;); props.put(\u0026#34;key.deserializer\u0026#34;, \u0026#34;org.apache.kafka.common.serialization.IntegerDeserializer\u0026#34;); props.put(\u0026#34;value.deserializer\u0026#34;, \u0026#34;com.example.messagequeuehomework.serializer.DataRecordDeserializer\u0026#34;); Consumer\u0026lt;Integer, DataRecord\u0026gt; consumer = new KafkaConsumer\u0026lt;\u0026gt;(props); consumer.subscribe(Collections.singletonList(\u0026#34;DisplayData\u0026#34;)); DataDisplay display = new DataDisplay(\u0026#34;信号捕获\u0026#34;, \u0026#34;信号序列\u0026#34;); while (true) { // 获取新的信号分析结果并显示 ConsumerRecords\u0026lt;Integer, DataRecord\u0026gt; records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord\u0026lt;Integer, DataRecord\u0026gt; record : records) { // System.out.println(\u0026#34;Display 显示\u0026#34;); display.plot(record.value().getLast(), record.value().getMax(), record.value().getMin(), record.value().getAverage(), record.value().getVariance()); } } } } GeneratorController\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import com.example.messagequeuehomework.server.RandomSignalGenerator; import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.Producer; import org.apache.kafka.clients.producer.ProducerRecord; import java.util.Properties; public class GeneratorController { private static final double u = 10; private static final double b = 16; public static void main(String[] args) { // 生成供 AnalyzerController 消费的消息，绑定主题 \u0026#34;RandomSignal\u0026#34; Properties props = new Properties(); props.put(\u0026#34;bootstrap.servers\u0026#34;, \u0026#34;localhost:9092\u0026#34;); props.put(\u0026#34;key.serializer\u0026#34;, \u0026#34;org.apache.kafka.common.serialization.IntegerSerializer\u0026#34;); props.put(\u0026#34;value.serializer\u0026#34;, \u0026#34;org.apache.kafka.common.serialization.DoubleSerializer\u0026#34;); Producer\u0026lt;Integer, Double\u0026gt; producer = new KafkaProducer\u0026lt;\u0026gt;(props); RandomSignalGenerator generator = new RandomSignalGenerator(u, b); int key = 0; while (true) { // 获取随机信号值，并发布 double val = generator.get(); producer.send( new ProducerRecord\u0026lt;Integer, Double\u0026gt;(\u0026#34;RandomSignal\u0026#34;, key++, val) ); // System.out.println(\u0026#34;Generator 消息发送\u0026#34;); // 通过 sleep 暂停100ms try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } DataDisplay\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 import org.knowm.xchart.SwingWrapper; import org.knowm.xchart.XYChart; import org.knowm.xchart.XYChartBuilder; import org.knowm.xchart.style.Styler; import javax.swing.*; import java.util.LinkedList; import java.util.List; public class DataDisplay { private SwingWrapper\u0026lt;XYChart\u0026gt; swingWrapper; private XYChart chart; private JFrame frame; private String title; private String seriesName; private List\u0026lt;Double\u0026gt; seriesData; private int size = 500; public int getSize() { return size; } public void setSize(int size) { this.size = size; } public String getSeriesName() { return seriesName; } public void setSeriesName(String seriesName) { this.seriesName = seriesName; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } /** * 实时绘图 * * @param seriesName * @param title */ public DataDisplay(String title, String seriesName) { super(); this.seriesName = seriesName; this.title = title; } public DataDisplay(String title, String seriesName, int size) { super(); this.title = title; this.seriesName = seriesName; this.size = size; } public void plot(double data, double max, double min, double average, double variance) { if (seriesData == null) { seriesData = new LinkedList\u0026lt;\u0026gt;(); } if (seriesData.size() == this.size) { seriesData.clear(); } System.out.printf(\u0026#34;max: %f, min: %f, average: %f, variance: %f\\n\u0026#34;, max, min, average, variance); seriesData.add(data); if (swingWrapper == null) { // Create Chart chart = new XYChartBuilder().width(600).height(450).theme(Styler.ChartTheme.Matlab).title(title).build(); chart.addSeries(seriesName, null, seriesData); chart.getStyler().setLegendPosition(Styler.LegendPosition.OutsideS); // 设置legend的位置为外底部 chart.getStyler().setLegendLayout(Styler.LegendLayout.Horizontal); // 设置legend的排列方式为水平排列 swingWrapper = new SwingWrapper\u0026lt;XYChart\u0026gt;(chart); frame = swingWrapper.displayChart(); frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // 防止关闭窗口时退出程序 } else { // Update Chart chart.updateXYSeries(seriesName, null, seriesData, null); swingWrapper.repaintChart(); } } } RandomSignalAnalyzer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import java.util.ArrayDeque; import java.util.Deque; public class RandomSignalAnalyzer { private final int N; private final AuxiliaryQueue que; private double maxi = Integer.MIN_VALUE; private double mini = Integer.MAX_VALUE; private class AuxiliaryQueue { private final int N; public Deque\u0026lt;Double\u0026gt; que = new ArrayDeque\u0026lt;\u0026gt;(); public AuxiliaryQueue(int N) { this.N = N; } public void add(double val) { que.add(val); if (que.size() \u0026gt; N) { que.remove(); } } public double getAverage() { double aver = 0; Double[] values = que.toArray(new Double[0]); for (Double val : values) { aver += val; } aver /= values.length; return aver; } public double getVariance() { double aver = getAverage(), variance = 0; for (Double val : que.toArray(new Double[0])) { variance += (val - aver) * (val - aver); } variance /= que.size(); return variance; } } public RandomSignalAnalyzer(int N) { this.N = N; que = new AuxiliaryQueue(N); } public void addNext(double val) { que.add(val); maxi = Math.max(maxi, val); mini = Math.min(mini, val); } public double getMaxi() { if (maxi == Integer.MIN_VALUE) return -1; return maxi; } public double getMini() { if (mini == Integer.MAX_VALUE) return -1; return mini; } public double getAverage() { return que.getAverage(); } public double getVariance() { return que.getVariance(); } public double getLast() { return que.que.getLast(); } public int getSize() { return que.que.size(); } } RandomSignalGenerator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.Random; public final class RandomSignalGenerator { private final double u; private final double b; private final Random random = new Random(); public RandomSignalGenerator() { u = 0; b = 1; } public RandomSignalGenerator(double u, double b) { this.u = u; this.b = b; } public double get() { return Math.sqrt(b) * random.nextGaussian() + u; } } ","date":"2022-05-06T10:55:24Z","image":"https://TuJin07.github.io/p/%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/cover_hu213652e9e8afc24335433dfd45f3b0e2_5684916_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/","title":"基于消息队列实现的分布式随机信号分析系统"},{"content":"乐观并发控制(OCC) 基本概念 二者在本质上都是用于处理并发情景下对共享资源的竞争问题的手段。乐观锁和悲观锁的区别则主要在于二者对于处理竞争问题的思想各不相同。\n乐观锁：操作共享资源时，抱以乐观的心态，认为别人不会同时修改数据。因此，乐观锁实际上并不会真正上锁，只是当数据修改后要写回更新时，会判断一下在此期间是否有其它线程修改了数据，如果修改了则放弃写回，否则写回更新。 悲观锁：操作共享资源时，抱以悲观的心态，认为别人一定会修改数据。因此，悲观锁在操作共享数据时会直接对数据上锁，直到操作完成后释放。上锁期间其他线程不能访问该资源。 实现方式 乐观锁与悲观锁本质上是两种思想，并不局限于某个具体的语言或者应用环境。我们熟知的比如 SQL 事务同步，或是 Java 线程同步，都包含这两种思想的实现。\n乐观锁的实现依靠 CAS 机制与版本号机制。\n悲观锁的实现依靠加锁，常见的比如对代码块加锁（ Java 中的 synchronized 关键字），也可以是对数据加锁（ MySQL 中的排它锁）。\nCAS 机制（Compare and Sway） CAS 是一种经典的无锁算法，即不通过加锁实现多线程之间的同步，换句话说，也是在没有线程被阻塞的情况下实现线程同步，也叫非阻塞同步（Non-Blocking Synchronization）。\nCAS 机制的实现依赖 3 个操作数。\nV：读写的内存位置。 A：比较的预期值。 B：拟写入的新值。 CAS 的思想是，当需要写回新值 B 时，先对内存位置 V 的值与预期值 A 进行比较，若相等，则写回 B，否则不进行任何操作。\n在这里用到了比较与替换两个操作，这两个操作是一个原子操作，即两个操作执行的中间不会被其它线程打断。能保证这一点，原因在于 CAS 是 CPU 支持的原子操作，其原子性实在硬件层面加以保证的。\nCAS 中的许多操作也具有自旋的特点，即如果操作不成功，会一直重试，直到操作成功。\n以下是一个使用乐观锁的 Java 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.util.concurrent.atomic.AtomicInteger; public class Test { // 不进行任何线程同步措施 private static int value1 = 0; // 使用基于CAS的乐观锁进行同步 private static AtomicInteger value2 = new AtomicInteger(0); public static void main(String[] args) throws Exception { // new 1000个线程并运行，每个线程对value做++操作，++操作包含取数，运算，写回的过程，是非原子操作 for(int i = 0; i \u0026lt; 1000; i++){ new Thread(new Runnable() { @Override public void run() { try { // 睡眠100毫秒以保证所有线程都创建后再开始执行操作 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } value1++; value2.getAndIncrement(); } }).start(); } // 保证所有线程都运行完成 Thread.sleep(1000); System.out.println(\u0026#34;value1: \u0026#34; + value1); System.out.println(\u0026#34;value2: \u0026#34; + value2); } } 运行会发现 value1 的结果往往小于 1000，原因就在于并发过程中有些线程操作的结果被覆盖了。\nAtomicInteger 是 java.util.concurrent.atomic 包下提供的原子类。它可以利用 CPU 提供的 CAS 操作来保证原子性，除此之外还有 AtomicBoolean、AtomicLong 等其它原子类。\nCAS 的缺点 ABA问题 有两个线程：线程1和线程2，按照顺序进行以下操作。\n线程1 读取内存中数据为 A\n线程2 将该数据修改为 B\n线程2 将该数据修改为 A\n线程1 对数据进行 CAS 操作\n最后一步中，由于内存中数据仍然为 A，因此 CAS 成功。但实际上该数据已经被修改过。这就是 ABA 问题。\n通常的例子而言，ABA 似乎没有什么危害。但某些特定场景下，比如对于栈顶判断的 CAS，一个栈的栈顶结果多次变化，恢复了原有的值，但实际上栈已经发生了变化。\n一个有效的解决方案是引入版本号机制，CAS 操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java 中的 AtomicStampedReference 类便是使用版本号来解决 ABA 问题的。\n高冲突下开销问题 并发冲突概率高的情况下，CAS 由于失败后自旋不断重试的特性，对于 CPU 的开销比较大。一个解决办法是引入重试超次数推出机制。不过，最好还是避免在高冲突概率的情况下使用乐观锁。\n功能受限 CAS 在某些功能上受限，比如只能保证单个变量（单个内存值）操作原子性。涉及到多个内存值时，CAS 机制也无能为力。\n另外一点是 CAS 需要硬件层面处理器的支持，Java 中只能通过原子类间接使用，灵活性受限。\n版本号机制 除了 CAS 机制，版本号机制同样用于实现乐观锁。其思路是在数据中增加一个 version 值，表示数据的版本号。每当数据被修改，该数据对应的 version 值需要加 1。\n在线程查询数据时，需要同时取出版本号；在线程写回更改时，需要先检查当前数据的版本号与之前读取的版本号是否一致，如果一致，说明在此期间没有其它线程修改数据，则执行修改，否则不执行。\n一般而言我们以“版本号”作为判断数据变化的标记，实际应用上可以依据实际情况选择任意可以标注数据版本的字段。\n以一个更新玩家金币数的例子说明。\n1 2 3 4 5 6 7 public void updateCoins(Integer playerId){ Player player = query(\u0026#34;select coins, level from player where player_id = {0}\u0026#34;, playerId); /* * 执行修改，结果写入 newCoins */ update(\u0026#34;update player set coins = {0} where player_id = {1}\u0026#34;, newCoins, playerId); } 如上的实现方式，没有进行任何线程安全方面的保护。如果有其他线程在query和update之间更新了玩家的信息，会导致玩家金币数的不准确。\n悲观锁通过加锁解决这个问题。\n1 2 3 4 5 6 7 8 public void updateCoins(Integer playerId){ // \u0026#34;for update\u0026#34; 加入排它锁 Player player = queryForUpdate(\u0026#34;select coins, level from player where player_id = {0} for update\u0026#34;, playerId); /* * 执行修改，结果写入 newCoins */ update(\u0026#34;update player set coins = {0} where player_id = {1}\u0026#34;, newCoins, playerId); } 通过版本号机制实现的乐观锁，信息中添加一个 version 字段，update 操作时，检查 version 是否发生变化，若有变化则不更新。\n1 2 3 4 5 6 7 8 9 public void updateCoins(Integer playerId){ // 包含 \u0026#34;version\u0026#34; Player player = query(\u0026#34;select coins, level, version from player where player_id = {0}\u0026#34;, playerId); /* * 执行修改，结果写入 newCoins */ // 如果 version 不相等则不做修改 update(\u0026#34;update player set coins = {0}, version = version + 1 where player_id = {1} and version = {2}\u0026#34;, newCoins, playerId, player.version); } 两种锁的应用场景 两种锁因为其各自的特性带来了不一样的特性，因此使用场景也各不相同。\n乐观锁更适用于竞争较少，即出现冲突概率小的场合。此种情境下，悲观锁一方面由于会锁住整个代码块或数据，导致并发度降低，另一方面悲观锁在加锁与解锁上都会使系统消耗额外资源。 悲观锁更适用于竞争较大，即出现冲突概率大的场合。此种情境下，乐观锁在执行更新失败时，需要不断自旋重试，非常消耗 CPU 资源。 补充：\nsynchronized 在 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。\nsynchronized 的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。\n参考 编程迷思\n面试必备之乐观锁与悲观锁\n","date":"2022-03-30T18:11:52Z","image":"https://TuJin07.github.io/p/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6occ/cover_hue7becf3ebdcf9a12aff59e93ae1b7a5f_1640219_120x120_fill_q75_box_smart1.jpg","permalink":"https://TuJin07.github.io/p/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6occ/","title":"乐观并发控制(OCC)"},{"content":"面向对象程序设计 C++ C++ 的初步知识 名字空间 名字空间的定义。\n1 2 3 4 5 6 7 namespace ns1 { int a; } namespace ns2 { int a; } 通过名字空间访问变量。\n1 2 ns1::a = 2; ns2::a = 3; 定义默认名字空间。\n1 2 3 using ns1::a; cout \u0026lt;\u0026lt; a; // a=2 cout \u0026lt;\u0026lt; ns2::a;\t// a=3 无名名字空间作用域为本文件中从声明无名名字空间的位置直到文件结束。\n1 2 3 namespace { int a; } 输入输出 cout 预定义的标准输出流对象，\u0026lt;\u0026lt; 是输出运算符。 cin 预定义的标准输入流对象，\u0026gt;\u0026gt; 是输入运算符。 常量 1 const int A = 100;\t// 一定要初始化，且为唯一赋值方式 const 有数据类型，宏常量没有。 函数原型声明 C++ 中，调用函数的位置在函数定义之前，则必须进行声明。\n1 void function(int var); 函数重载 重载函数的参数个数或类型必须至少有其中之一不同。不允许重载的函数只有返回类型不同。\n1 2 3 4 5 6 7 void function(int a) { ... } void function(double a) { ... } 函数模板 函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。\n函数模板定义。\n1 2 3 template \u0026lt;typename 类型参数1 , typename 类型参数2 , ...\u0026gt; 返回值类型 函数名(形参列表) { //在函数体中可以使用类型参数 } 举个例子。\n1 2 3 4 template\u0026lt;typename T\u0026gt; T max(T a, T b) { T c = a; return a \u0026gt; b ? a : b; } 函数模板是对一组函数的描述，不是一个实实在在的函数，编译系统并不产生任何执行代码。\n当编译系统在程序中发现有与函数模板中相匹配的函数调用时，便生成一个重载函数，该重载函数的函数体与函数模板的函数体相同。\n函数模板比函数重载更方便，程序更简洁。\n带默认参数的函数 1 2 3 4 void function(int a = 6); ... function(2);\t// a = 2 function();\t// a = 6 指定默认值的参数必须在形参列表的最右端。\n1 void function(int a, int c, int b = 10, int d = 10); 引用 为变量起一个别名，称为引用。\n1 2 int\ta; int\u0026amp; b = a; 原变量名必须是一个已定义过的变量。 b 并没有重新在内存中开辟存储单元，只是引用 a 的单元，内存中占用同一地址，即同一地址两个名字。 引用时需要初始化，且不能为常数。\n1 2 3 4 5 6 int\u0026amp; a;\t// error int\u0026amp; a = 1;\t// error int b; int\u0026amp; a = b;\t// 右值可以为变量 int\u0026amp; c = a;\t// 右值可以为引用 声明后不可以指向其他变量。\n1 2 3 int a, b; int \u0026amp;c = a; \u0026amp;c = b;\t// error 引用的指针 1 2 3 4 int a; int\u0026amp; b = a;\t// b 作为 a 的引用 int* p = \u0026amp;b;\t// 指针 p 指向引用 b *p = 10; 注意区别 \u0026amp; 什么时候表示地址，什么时候表示引用。\n常量引用 1 2 3 4 int a = 5; const int\u0026amp; b = a; b = 2;\t// rejected a = 2;\t// allowed 一些非法的引用。\n1 2 3 void\u0026amp; a;\t// void 类型的引用 int\u0026amp; a[6];\t// 建立引用类型的数组 int\u0026amp; *p;\t// 指向引用类型的指针 指针与引用的区别 指针是通过地址间接访问某个变量，而引用是通过别名直接访问某个变量。 引用必须初始化，而一旦被初始化后不得再作为其它变量的别名。指针若不进行初始化，编译器不会报错。 函数传参 值传递：传递变量的值。 指针传递：传递变量的地址。 引用传递：传递变量的别名。 指针传递与引用传递的区别 引用作为形参，实参是变量；指针变量作形参,实参是地址。 指针变量要另外开辟内存单元，其内容是地址；引用不是一个独立的变量，不单独占内存单元。 必须用指针运算符 * 来表示指针变量所指向的变量；而引用就代表该变量。因此引用比指针更直观、方便、容易理解。 函数返回值为引用类型 返回值为引用类型时，函数可以在左值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a = 4; int\u0026amp; f( int x ) { a = a + x; // 返回 a 的引用，即 \u0026amp;a return(a); } int main() { int t = 5; cout \u0026lt;\u0026lt; f( t ) \u0026lt;\u0026lt; endl;\t// 9 f( t ) = 20;\t// 相当于 \u0026amp;a=20 cout \u0026lt;\u0026lt; f( t ) \u0026lt;\u0026lt; endl;\t// 25 return(0); } 返回的变量的引用，这个变量必须是全局变量或静态局部变量，即存储在静态区中的变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int\u0026amp; f( int \u0026amp;x ) { static int t = 2;\t// 静态局部变量 t = x++; return(t); } int main() { int a = 3; cout \u0026lt;\u0026lt; f( a ) \u0026lt;\u0026lt; endl;\t// a = 4, t = 3, cout \u0026lt;\u0026lt; 3 f( a )\t= 20;\t// a = 5, t = 20 a\t= a + 5;\t// a = 10 cout \u0026lt;\u0026lt; f( a ) \u0026lt;\u0026lt; endl;\t// a = 11, t = 10, cout \u0026lt;\u0026lt; 10 return(0); } 内联函数 编译时将调用函数的代码嵌入到主函数中，叫内联函数。编译器调用正确后，内联函数的代码直接替换函数调用，并且用实参调换形参，省去了调用函数的时间开销，这是一种用空间换时间的机制。\n1 2 3 inline int max(int a, int b) { ... } 作用域运算符 每个变量都有其有效的作用域。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; float a = 13.5; int main() { int a = 5; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ::a \u0026lt;\u0026lt; endl;\t// ::a 表示全局变量中的 a return(0); } string 赋值运算符实现字符串赋值。相当于从 str2 拷贝至 str1，区别于 Java 中指向对象的引用。\n1 string str1 = str2; 内存的动态分配与撤销 new 运算符从堆中分配一块与\u0026lt;类型\u0026gt;相适应的存储空间，若分配成功，将这块存储空间的起始地址存入\u0026lt;指针变量名\u0026gt;。\n1 2 3 4 5 6 7 \u0026lt;指针变量名\u0026gt; = new \u0026lt;类型\u0026gt;; \u0026lt;指针变量名\u0026gt; = new \u0026lt;类型\u0026gt;(\u0026lt;初值\u0026gt;); \u0026lt;指针变量名\u0026gt; = new \u0026lt;类型\u0026gt;[\u0026lt;元素个数\u0026gt;]; int* p = new int; int* q = new int(10); int* r = new int[10]; delete 释放动态存储空间。\n1 2 3 4 5 delete \u0026lt;指针变量名\u0026gt;; delete[] \u0026lt;指针变量名\u0026gt;;\t// 释放数组空间 delete p delete r 习题 找出错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; c = add( a, b )\t// 1, 2, 3 cout \u0026lt;\u0026lt; \u0026#34;a+b=\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return(0); } int add( int x, int y );\t// 4 { z = x + y;\t// 5 return(z); } 函数调用前未声明。 缺少 ;。 变量 c 未声明。 去掉 ;。 变量 z 未声明。 写出输出结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void dd( int \u0026amp;x, int \u0026amp;y, int z ) { x\t= x + z; y\t= y - x; z\t= 10; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } int main() { int a = 3, b = 4, c = 5; for ( int i = 0; i \u0026lt; 2; i++ ) dd( a, b, c ); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return(0); } i a b c - 3 4 5 0 8 -4 5 1 13 -17 5 1 2 3 8, -4, 10 13, -17, 10 13, -17, 5 类和对象的特性 对象和类 对象：将数据与功能捆绑在一起的软件结构，这两部分结合起来表示实际对象的抽象。\n类：类是描述一组相似对象共有特征的抽象。\n对象和类的关系：\n对象是类的一个具有特定属性值的具体实例。 从一个类可以创建（实例化）多个对象。 相同类的两个对象具有相同的属性和函数，但属性值不同。 类的定义 回顾下结构体定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Account { char id[16]; //账号 char name[50]; //户名 char pwd[6]; //密码 double balance; //余额 double checkBalance() { return balance; } }; int main() { struct Account a; //C++中，可以省略struct a.balance = 10000; cout\u0026lt;\u0026lt;\u0026#34;balance = \u0026#34;\u0026lt;\u0026lt;a.balance \u0026lt;\u0026lt;endl; return 0; } 在C++中，一个结构体代表一个所有成员都是public的类，该类不能对外界隐藏自己的重要信息和私密信息。结构体表示一个没有封装的类。 类的定义如下。\n1 2 3 4 5 6 7 class Account { char id[16]; //账号 char name[50];\t//户名 char pwd[6]; //密码 double balance; //余额 }; 访问权限控制 public：任何地方可以被访问，是对外接口，类外只能访问公有成员（除继承外）。 private：只能被本类中的成员函数和友元访问。 protected：对派生类而言，保护成员如同共有成员；对其它程序则如私有成员。 1 2 3 4 5 6 7 8 class Time { public：\t//外部接口，公有成员函数 void SetTime(int NewH, int NewM, int NewS)； void ShowTime()； private：\t//私有数据成员 int Hour,Minute,Second； }； 类的说明部分与实现部分 1 2 3 4 5 6 7 8 class Time { public: void SetTime(int NewH,int NewM,int New S); void ShowTime(); private: int Hour,Minute,Second; }; 成员函数是类中描述行为的成员，同时也是对封装的数据进行操作的唯一途径。 成员函数的实现既可以在类中，也可以在类外。从类定义的格式可知，一般在类中声明成员函数，在类外具体实现成员函数。 如果成员函数已经在类中定义，则不需要在类外实现。需要注意的是，在类中定义的成员函数自动成为内联函数。 类中实现成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; class Time /* 时间类的定义 */ { public: /* 外部接口，公有成员函数 */ void SetTime( int NewH, int NewM, int NewS ) { Hour\t= NewH; Minute\t= NewM; Second\t= NewS; } void ShowTime() { cout \u0026lt;\u0026lt; Hour \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; Minute \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; Second \u0026lt;\u0026lt; endl; } private: /* 私有数据成员 */ int Hour, Minute, Second; }; 类外实现成员函数 需要使用作用域运算符 ::，标识成员函数属于哪个类。\n成员函数必须先在类内声明，而且类体必须在成员函数定义之前出现。\n1 2 3 4 5 6 void Time::SetTime( int NewH, int NewM, int New S ) { Hour\t= NewH; /* 成员函数可直接访问私有成员 */ Minute\t= NewM; Second\t= NewS; } 跨文件声明略。\n创建对象 除了一般创建对象，可以在声明类同时创建对象。\n1 class \u0026lt;类名\u0026gt; {...} \u0026lt;对象名\u0026gt;; 类作用域 类的成员函数与数据成员，其作用域都是属于类的作用域，仅在该类的范围内有效，故不能在主函数中直接通过函数名和成员名来调用。\n对象存储空间 象空间中只有数据成员，而无成员函数的空间。成员函数只存储一份，由对象共享。\n习题 找出错误并改正。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; class Time { void set_time(); void show_time(); int\thour; int\tminute; int\tsec; }; Time t; int main() { set_time();\t// 1 show_time();\t// 2 return(0); } void set_time()\t// 3 { cin \u0026gt;\u0026gt; t.hour;\t// 4 cin \u0026gt;\u0026gt; t.minute;\t// 5 cin \u0026gt;\u0026gt; t.sec;\t// 6 } void show_time()\t// 7 { // 8 cout \u0026lt;\u0026lt; t.hour \u0026lt;\u0026lt; “ : ” \u0026lt;\u0026lt; t.minute \u0026lt;\u0026lt; “ : ” \u0026lt;\u0026lt; t.sec \u0026lt;\u0026lt; endl; } set_time() 改为 t.set_time()\nshow_time() 改为 t.show_time()\nvoid set_time() -\u0026gt; void Time::set_time()\nt.hour -\u0026gt; this-\u0026gt;hour OR hour\nt.minute -\u0026gt; minute\nt.sec -\u0026gt; sec\nvoid show_time() -\u0026gt; void Time::show_time()\n同 4,5,6\n使用类和对象 构造函数 \u0026amp; 析构函数 C++ 把对象的初始化工作放在构造函数中，把清除工作放在析构函数中。\n当对象被创建时，构造函数被自动执行，当对象消亡前，析构函数被自动执行。\n构造函数 如果在类中没有显式定义构造函数，那么编译系统就会自动生成一个默认形式的构造函数，这个构造函数的功能仅用于创建对象。\n1 Time::Time() {} 只要显式定义了一个类的构造函数，则编译器就不产生默认的构造函数。\n不存在没有构造函数的对象。\n类数据成员的初始化 构造函数体内初始化 1 2 3 4 5 6 Box::Box(int h,int w,int len) { height=h; width=w; legth=len; } 构造函数初始化列表 1 Box::Box(int h,int w,int len):height(h),width(w),length(len){} 带默认参数的构造函数 1 2 3 4 5 6 7 Box(int w=10,int h=10,int len=10); Box::Box(int w,int h,int len) { height=h; width=w; length=len; } 声明构造函数时形参名可以省去\n注意二义性问题。\n析构函数 析构函数的功能是在对象的生存期即将结束的时刻，由编译系统自动调用来完成一些清理工作。 析构函数也是类的一个公有成员函数，它的名称是由类名前面加“~”构成，也不指定返回值类型。 析构函数没有参数，因此不能重载。一个类中只能定义一个析构函数。（构造函数允许重载） 1 2 3 4 5 ~Box(); //析构函数的声明 Box::~Box() //析构函数的实现 { cout\u0026lt;\u0026lt;“This is destructor!”\u0026lt;\u0026lt;endl; } 默认形式的析构函数 1 \u0026lt;类名\u0026gt;::~\u0026lt;类名\u0026gt;(){} 构造函数与析构函数的调用顺序 构造函数与析构函数调用时机 全局对象的构造函数在文件中的所有函数（包括main函数）执行之前调用。当main函数执行完毕或调用exit函数时，调用析构函数。 自动局部对象在建立对象时调用构造函数。在函数调用结束、对象释放时先调用析构函数。 函数中的静态局部对象，在第一次调用此函数建立对象时调用一次构造函数，在调用结束时对象并不释放，因此也不调用析构函数， 只在main函数执行完毕或调用exit函数时，调用析构函数。 1 2 3 4 5 6 7 void fn( ) { Student stud1;//定义自动局部对象 static Student stud2;//定义静态局部对象 … } // 函数调用顺序为：stud1的构造函数，stud2的构造函数，stud1的析构函数，stud2的析构函数。 复制（拷贝）构造函数 两种途径可以生成一个对象的副本。\n同类对象赋值（被赋值对象已经存在） 同类对象之间可以整体赋值，无关于成员访问权限。\n1 2 3 4 Time time1, time2; time1.setTime(10); time2 = time1; time2.print();\t// 10 对象复制（从无到有建立一个新对象） 对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。 对象的复制是从无到有地建立一个新对象，并使它与一个已有的对象完全相同。 复制构造函数 用一个类对象初始化该类的另一个对象被称为默认按成员初始化。 类的设计者也可以通过提供特殊的复制构造函数（copy constructor）来改变默认的行为。 复制构造函数是一种特殊的构造函数，它的功能是用一个已知的对象来初始化一个被定义的同类的对象。 1 2 3 4 TAdd(const TAdd\u0026amp; p) { x = p.x; y = p.y; } 所谓对象的复制本质上就是通过特殊的构造函数即复制构造函数来新创建一个对象。这个构造函数可以自己设计，否则编译器也会自己创建，其功能是创建新对象把已知对象的每个数据成员的值都复制到新创建的对象中，而不做其他处理。\n1 2 3 4 5 // 三种构造函数 Box(); //无参构造函数 Box(int h,int w ,int len):height(h),width(w),length(len){} //带参构造函数 Box(const Box\u0026amp; b);//复制构造函数 需要复制对象的情况 1 2 3 Box box1(15,30,25); Box box2=box1;\t// 用 box1 复制 Box box3(box1);\t// 用 box1 复制 1 2 3 4 5 6 7 8 9 // 当函数的参数为类对象时，在调用函数时需要将实参对象完整地传递给形参： void fun(Box b) //形参是类的对象 { … } int main( ) { Box box1(12,15,18); fun(box1); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 // 当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时： Box f( ) { Box box1(10,20,30); return box1; } int main( ) { Box box2; box2=f( ); return 0; } 对象间数据共享 静态成员 如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为静态成员。它在对象中不占存储空间，是属于整个类的成员。\n静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。它是在程序编译时分配空间，到程序结束时才释放空间。\n1 static int a; 只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被访问。 在一个类中可以有一个或多个静态数据成员，所有的对象共享这些静态数据成员，都可以访问它。 静态成员初始化 静态数据成员只能在类体外进行初始化。\n1 int ClassName::elem = 0;\t// 不需要加 static 静态成员的访问 类体内可以直接访问，类体外：\n1 2 3 MyClass myclass(\u0026#34;hello\u0026#34;); myclass.staticElem; MyClass::staticElem; 静态成员与全局变量 静态数据成员与全局变量一样都是静态分配存储空间的，但全局变量在程序中的任何位置都可以访问它，而静态数据成员受到访问权限的约束。必须是public权限时，才可能在类外进行访问。 公有静态数据成员的作用域只限于定义该类的作用域内。在此作用域内，可以通过类名和作用域运算符访问静态数据成员，而不论类对象是否存在。 静态成员函数 静态成员函数的作用不是为了对象之间的沟通，是为了能处理静态数据成员。\n静态成员函数没有this 指针。\n1 static int get() {return sum;} 静态成员函数可以直接访问该类的静态成员，但不能直接访问类中的非静态成员。 如果静态成员函数中要使用非静态成员时，必须通过参数传递方式得到对象名，然后可以通过对象名来访问非静态成员。（不受访问权限控制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Tc { private:int a; static int b;\t// 静态数据成员 public:Tc(int c){a=c; b+=c;} static void display(Tc C)\t// Tc的对象作为形参能访问非静态成员 { cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;C.a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; } }; int Tc::b=2; int main() {\tTc A(2),B(4);\t// A.a=2, B.a=4, b=8 Tc::display (A); Tc::display (B); return 0; } 对象指针 初始化。\n1 2 ListNode listnode; ListNode* p = \u0026amp;listnode; 访问对象成员。\n1 2 p -\u0026gt; next; (*p).next; 动态对象 new 运算符创建动态对象。\n1 2 ListNode* q = new ListNode; ListNode* p = new ListNode(10); delete 运算符释放指针指向的内存空间，此时自动执行析构函数。\n1 delete p; this 指针 隐含于每一个成员函数（静态成员函数除外）中，也就是说，每个成员函数都有一个this指针参数。\nthis指针指向调用该函数的对象，即this指针的值是当前被调用的成员函数所在的对象的起始地址。\n当一个对象调用成员函数时，编译系统先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，则隐含使用this指针。\n通常不显式地使用this指针来调用数据成员。\nthis指针是一个const指针，成员函数不能对其进行赋值。\n1 2 3 4 5 6 7 8 int Box::volume() { return(height*width*length);\t// 隐含使用 this 指针 } int Box::volume(Box *this)\t// 在实际编程时，函数的声明中并没有包含这个参数。编译器会把该对象的地址加入到参数列表中。 { return(this-\u0026gt;height)*(this-\u0026gt;width)*(this-\u0026gt;length); } 成员指针 使指针直接指向对象的成员，进而可以通过这些指针访问对象的成员。\n指向非静态数据成员 指向非静态成员函数 1 2 返回类型(\u0026lt;类名\u0026gt;::*\u0026lt;指针变量名\u0026gt;)(参数列表)=\u0026amp;类名::成员函数名 // \u0026amp;可以省略 int (ClassName::*pFun)(int a) = \u0026amp;ClassName::Fun; 1 2 3 4 5 6 7 8 9 10 11 Point A(4,5);//声明对象A //声明对象指针并初始化 Point *p1=\u0026amp;A; //声明成员函数指针并初始化 int (Point::*pGetX)()= Point::GetX; //使用成员函数指针访问成员函数 cout\u0026lt;\u0026lt;(A.*pGetX)()\u0026lt;\u0026lt; endl; //使用对象指针访问成员函数 cout\u0026lt;\u0026lt;(p1-\u0026gt;GetX)()\u0026lt;\u0026lt; endl; //使用对象名访问成员函数 cout\u0026lt;\u0026lt;A.GetX()\u0026lt;\u0026lt;endl; 指向类的静态成员的指针 对类的静态成员的访问是不依赖于对象的，因此可以用普通的指针来指向和访问静态成员。\n1 int *p = \u0026amp;ClassName::staticElem; 对象引用 声明引用时必须初始化为一个对象。\n1 2 Time myTime; Time\u0026amp; refTime = myTime; 如果实参是对象，那么“通过值来传递一个对象”的具体含义是由这个对象的复制构造函数定义的。 1 2 3 Student returnS(Student s){return s;} Student stu1; stu1.returnS(stu1); 避免通过值来传递对象，而是通过引用来传递。 1 2 3 Studen t\u0026amp; returnS(Student\u0026amp; s) {return s;} 参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率。\n共享数据的保护 常对象 常对象的数据成员值在生存期间不能被改变。\n1 const ClassName objecct(); 常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。 不能通过常对象调用普通的成员函数，可以调用常成员函数。 如果要修改常对象中某个数据成员的值，可以将数据成员声明为mutable，这样就可以用声明为const的成员函数来修改它的值。 常成员 数据成员和成员函数可以声明为 const。\n常数据成员 任何函数不能对其赋值。 非静态常数据成员只能通过构造函数初始化表初始化。 1 2 const int Hour; Time::Time(int h):Hour(h){} 静态常数据成员可以在类外初始化。 1 2 3 static const int b; ... const int ClassName::b = 10; 类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员的值可以不同（在定义对象时给出）。 常成员函数 常成员函数可以引用本类中的数据成员，但不能修改他们。\n1 2 3 4 5 void print() const; ... void ClassName::print() const { ... } 常对象只能调用其中的常成员函数。 const 可用于重载区分。 常成员函数不能更新对象的数据成员，也不能调用该类中的非常成员函数。 const 成员和非 const 成员之间的调用关系。\nconst 与常指针 常指针 因为是常指针，所以 const 后面直接接指针变量。\n1 2 3 4 Time t1(10,12,15),t2; Time* const ptr1=\u0026amp;t1;\t//ptr1是指向t1对象的常指针 ptr1=\u0026amp;t2; //错误，ptr1不能改变指向 // 常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值 。 指向常对象的指针 因为是常对象，所以 const 后面接 Time\n1 const Time* ptr = \u0026amp;t1; 常对象只能用指向常对象的指针指向它，而不能用非const型的指针指向它。\n指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值；但是指针本身的值可以改变。 1 2 3 4 5 Time t1(10,12,15),t2; const Time* p=\u0026amp;t1;\t//p是指向常对象的指针，并指向t1对象 (*p).hour=18; //错误，不能通过指针改变t1的值 t1.hour=18;\t//正确，t1不是常对象 p=\u0026amp;t2;\t//正确，p改为指向t2 指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。(修改权限的问题) 常引用 常引用所引用的对象不能被更新。\n1 const ClassName\u0026amp; a = object; 函数中也不能修改 t 的值，即不能改变对应实参对象的值。\n1 void fun(const Time\u0026amp; t); 对象数组 建立对象数组。\n1 Student stus[10]; 定义数组时可以提供实参，以初始化，如果构造函数只有一个参数，可以直接在大括号内提供。\n1 Student stus[3] = {1,2,3}; 如有多个参数。\n1 Student stus[3] = {stus(0,1), stus(0,2), stus(1,3)}; 实际上构造函数 stus() 本身返回的就是对象。\n对象成员 一个类对象作为另一个类的成员，这个对象称为对象成员或者子对象。\n1 2 3 4 5 6 7 8 class A { int i; }; class B { int j; A a;\t// 注意 class A 要先声明 } 初始化。\n1 2 3 4 5 B::B(const A \u0026amp;a):a(a){...} // 或 B::B(const A \u0026amp;a) { this -\u0026gt; a = a; } 例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Point { public: Point(int xx=0,int yy=0) { X=xx; Y=yy; } Point(const Point\u0026amp; p) { X=p.X; Y=p.Y; cout\u0026lt;\u0026lt;\u0026#34;In Point copy constructor.\u0026#34;\u0026lt;\u0026lt;endl; } int GetX() { return X; } int GetY() { return Y; } private: int X,Y; } ; class Distance { public: Distance(Point xp1,Point xp2); double GetD() { return dist; } private: Point p1,p2; //对象成员p1，p2 double dist; } ; //构造函数中通过调用复制构造函数初始化对象成员p1、p2 Distance::Distance(Point xp1,Point xp2):p1(xp1),p2(xp2) { cout\u0026lt;\u0026lt;\u0026#34;in Distance constructor.\u0026#34;\u0026lt;\u0026lt;endl; double x=double(p1.GetX()-p2.GetX()); double y=double(p1.GetY()-p2.GetY()); dist=sqrt(x*x+y*y); } int main()//主函数 { Point myp1(2,2),myp2(5,6); //定义Point类的对象myp1，myp2 Distance myd(myp1,myp2); //定义 Distance类的对象myd cout\u0026lt;\u0026lt;\u0026#34;The distance is:\u0026#34;; cout\u0026lt;\u0026lt;myd.GetD()\u0026lt;\u0026lt;endl; return 0; } In Point copy constructor. In Point copy constructor. In Point copy constructor. In Point copy constructor. in Distance constructor.\n一般来说，在类中出现了对象成员时，创建本类对象既要对本类的数据成员进行初始化，又要对对象成员进行初始化。 先调用对象成员的构造函数，再调用本类的构造函数。析构函数的调用顺序刚好相反。 如果调用本类默认形式的构造函数，那么也只能调用对象成员的默认形式的构造函数。 对象成员数组 类模板 同函数模板一样，使用类模板可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值能取任意类型。 类模板是对一批仅有成员数据类型不同的类的抽象。 1 2 3 template \u0026lt;class T\u0026gt; class compare { ... }; 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;class T\u0026gt; class Compare { public: Compare() { x=0; y=0; } Compare(T a, T b) { x=a; y=b; } T max() { return(x\u0026gt;y)?x:y; } private: T x,y; }; 由于类模板包含类型参数，因此又称为参数化的类。如果说类是对象的抽象，对象是类的实例，则类模板是类的抽象，类是类模板的实例。 由类模板经实例化而生成的具体类称之为模板类。 创建实例对象。\n1 2 Compare\u0026lt;int\u0026gt; cmp1; Compare\u0026lt;int\u0026gt; cmp2(3, 7); 逻辑关系。\n类模板成员函数定义 可以放在类模板的定义体中（此时与类中的成员函数的定义方法一致。） 也可以放在类模板的外部，此时成员函数的定义格式如下： 1 2 3 template\u0026lt;class T\u0026gt; T Compare\u0026lt;T\u0026gt;::max() { return x \u0026gt; y ? x : y; } 在类模板外定义成员函数时，每一个函数前均加上： template \u0026lt;class 类型参数\u0026gt;\n多个参数：\n1 2 3 template\u0026lt;class T1, classT2\u0026gt;... ... ClassName\u0026lt;int, double\u0026gt; object; 默认参数：\n1 2 3 template\u0026lt;class T = int\u0026gt;... ... ClassName\u0026lt;\u0026gt; object; 练习 写出运行结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class CPicture { bool m_bSatiate; char m_szName[20]; public: CPicture(char *szName=NULL); CPicture(CPicture\u0026amp; CopyPicture); ~CPicture() { cout\u0026lt;\u0026lt;\u0026#34;展览结束了，\u0026#34;\u0026lt;\u0026lt;m_szName\u0026lt;\u0026lt;\u0026#34;也该撤去了\u0026#34;\u0026lt;\u0026lt;endl; } char *GetName() { return m_szName; } void Show() { m_bSatiate=true; } void Finish() { if(m_bSatiate) cout\u0026lt;\u0026lt;\u0026#34;这么美的画一定有很多人喜欢!\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;都什么时候了还不开展!\u0026#34;\u0026lt;\u0026lt;endl; } }; CPicture::CPicture(char *szName) { m_bSatiate=false; if(szName==NULL) { cout\u0026lt;\u0026lt;“画家还没有为我命名\u0026#34;\u0026lt;\u0026lt;endl; m_szName[0]=\u0026#39;\u0026#39;; } else {\tstrcpy(m_szName,szName); cout\u0026lt;\u0026lt;\u0026#34;我是\u0026#34;\u0026lt;\u0026lt;m_szName\u0026lt;\u0026lt;\u0026#34;，是一幅美丽的油画\u0026#34;\u0026lt;\u0026lt;endl; } } CPicture::CPicture(CPicture\u0026amp; CopyPicture) { m_bSatiate=false; strcpy(m_szName,CopyPicture.GetName()); strcat(m_szName,\u0026#34;的复制品\u0026#34;); cout\u0026lt;\u0026lt;\u0026#34;我是\u0026#34;\u0026lt;\u0026lt;m_szName\u0026lt;\u0026lt;\u0026#34;,也是一幅油画\u0026#34;\u0026lt;\u0026lt;endl; } void Begin(CPicture Picture) { Picture.Show(); } int main() { CPicture Picture(\u0026#34;日出\u0026#34;); Begin(Picture); Picture.Finish(); return 0; } 我是日出，是一幅美丽的油画\n我是日出的复制品，也是一副油画\n展览结束了，日出的复制品也该撤去了\n都什么时候了还不开展！\n展览结束了，日出也该撤去了\n运算符重载 定义 运算符重载就是为用户自定义类型重新定义运算符，使同一个运算符既可以作用于预定义的数据类型，也可以作用于用户自定义的数据类型。\n运算符重载本质上是一种特殊的函数重载。\n为了重载运算符，必须定义一个运算符重载函数，由这个函数来完成该运算符应该完成的操作。运算符的操作数通常是类的对象。 可以将运算符重载函数作为类的成员函数或者是友元函数。 格式。\n1 2 3 \u0026lt;函数类型\u0026gt; operator \u0026lt;运算符\u0026gt;(\u0026lt;参数表\u0026gt;) { 函数体 } 如：\n1 2 3 4 5 6 7 8 Complex operator+(Complex\u0026amp; c); ... Complex Complex::operator+(Complex\u0026amp; c) { Complex temp; temp.real = real + c.real; temp.imag = imag + c.imag; return temp; } 调用\n1 2 3 4 5 6 7 8 9 10 11 int main() { Complex c1(3.3, 2.5); Complex c2(2.1, 1.4); Complex c3, c4; c3=c1+c2;\t// c3=c1.operator+(c2); c4=c1-c2;\t// c4=c1.operator-(c2); cout\u0026lt;\u0026lt;\u0026#34;c3= \u0026#34;\u0026lt;\u0026lt;c3.Real( ) \u0026lt;\u0026lt;\u0026#34; +i \u0026#34;\u0026lt;\u0026lt;c3.Imag( )\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;c4= \u0026#34;\u0026lt;\u0026lt;c4.Real( )\u0026lt;\u0026lt;\u0026#34; +i \u0026#34;\u0026lt;\u0026lt;c4.Imag( )\u0026lt;\u0026lt;endl; return 0; } 三目运算符不允许重载。 运算符重载为成员函数时最多有一个形参，参数可以是对象，对象的引用，或其它类型的参数。 运算符重载的实质就是函数重载，只不过函数名换成了关键字operator和具体要重载的运算符。 运算符重载的函数参数就是该运算符涉及的操作数，因此运算符重载在参数个数上是有限制的，这是它不同于函数重载之处。 重载之后运算符的优先级和结合性都不会改变，并且要保持原运算符的语法结构。参数和函数值类型都可以重新说明，但不能有默认的参数。 如果是双目运算符，左操作数一定是对象本身，由this指针给出（this.i += object.i），另一个操作数需要由运算符重载的参数表来传递。 运算符重载函数不能定义为静态的成员函数，因为静态的成员函数中没有this指针。 单目运算符重载 ++ 前置\n1 \u0026lt;type\u0026gt; operator ++() { ... } ++ 后置\n1 \u0026lt;type\u0026gt; operator ++(int) { ... } 运算符重载为成员函数后，它可以访问类的所有成员。使用该函数时，总是通过该类的某个对象来访问。\n两种返回形式 返回新的对象。\n1 2 3 4 5 6 A operator ++( ) { A t; t.x=++x; t.y=++y; return t; } 返回对象本身。\n1 2 3 4 5 A operator ++( ) { ++x; ++y; return *this; } 友元 C++从高效的角度出发，提供友元机制，使友元可以直接访问当前类中的私有成员，又不改变其私有成员的访问权限。\n友元可以是一个普通函数、另一个类的成员函数或者是一个类。分别称为友元函数和友元类。\n友元声明以关键字friend开始，只能出现在被访问类的定义中。\n1 2 friend \u0026lt;函数值类型\u0026gt; \u0026lt;函数名\u0026gt;(\u0026lt;参数表\u0026gt;); friend class \u0026lt;类名\u0026gt;; 一个类的友元可以使用该类中的所有成员。 友元函数不是该类的成员函数，它破坏了类的封装性和隐蔽性，使得非成员函数可以访问类的私有成员。 友元函数是普通函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class A { float x,y; public: A(float a, float b) { x=a; y=b; } float Getx( ) { return x; } float Gety( ) { return y; } float Sum( ) // 成员函数 { return x+y; } friend float Sum(A \u0026amp;);\t// 友元函数声明 } ; float Sum(A \u0026amp;a) // 友元函数定义，不用带friend 直接访问 a 的私有数据 { return a.x+a.y; } float Sumxy(A \u0026amp;a) // 普通函数，通过接口访问 a { return a.Getx( )+a.Gety( ); } int main() { A t1(1,2),t2(10,20), t3(100,200); cout\u0026lt;\u0026lt;t1.Sum( )\u0026lt;\u0026lt;endl;\t// 对象调用成员函数 cout\u0026lt;\u0026lt;Sum(t2)\u0026lt;\u0026lt;endl;\t// 直接调用友元函数 cout\u0026lt;\u0026lt;Sumxy(t3)\u0026lt;\u0026lt;endl;\t// 直接调用普通函数 return 0; } 友元函数近似于普通函数，它不带有this指针，因此必须将对象名或对象的引用作为友元函数的参数，这样才能访问到对象的成员。 友元函数的作用域与普通函数的作用域相同。 友元函数可以访问该类中的所有成员（公有的、私有的和保护的），而普通函数只能访问类中的公有成员。 类中对友元函数指定访问权限不起作用。 友元函数必须在类的定义中声明，其函数体可在类内定义，也可在类外定义。 友元函数是某个类的成员函数 1 2 3 4 5 6 7 class A{ void Sum( B \u0026amp;);\t// A类的成员函数 }; class B{ friend void A::Sum( B \u0026amp;);\t// B类的友元函数 }; 实现类与类之间的沟通。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class B;\t//先定义A类，则首先对B类作引用性说明 class A { float x,y; public: A(float a, float b) { x=a; y=b; } void Sum(B \u0026amp;);\t//说明友元函数的函数原型，是A类的成员函数 } ; class B { float m,n; public: B(float a,float b) { m=a; n=b; } friend void A::Sum(B \u0026amp;);\t//说明A类的成员函数是B类的友元函数 } ； void A::Sum( B \u0026amp;b)\t//定义该友元函数 { x=b.m+b.n;\t// 可以直接引用B类的私有成员 y=b.m-b.n; } int main() { A a1(3,5); B b1(10,20); a1.Sum(b1); //调用该函数，因是A类的成员函数，故用A类的对象调用 return 0; } 友元类 1 2 3 4 5 6 7 8 class A{ ..... friend class B; }; class B{ ..... }; 对于B类而言，A类是透明的。 友元类的所有成员函数都是友元函数，可以访问被访问类的任何成员。 友元是单向的，即 B 是 A 的友元，B 可以使用 A 的所有成员，A 不能直接使用 B 的私有成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 const double PI =3.1415926; class A { float r ; float h; public:\tA(float a,float b) { r=a; h=b; } float Getr( ) { return r; } float Geth( ) { return h; } friend class B;\t// B类中的任何函数都能使用A类中的所有成员。 //定义B类为A类的友元 } ; class B { int number; public:\tB(int n=1) { number=n; } void Show(A \u0026amp;a) { cout\u0026lt;\u0026lt;PI*a.r*a.r*a.h*number\u0026lt;\u0026lt;endl;\t// 直接引用A类的私有成员 } //求A类的某个对象*n的体积 } ; int main() { A a1(25,40),a2(10,40); B b1(2); b1.Show (a1)；\tb1.Show (a2); return 0; } 友元的出现主要是为了解决一些实际问题，友元本身不是面向对象的内容。 通过友元机制，一个类或函数可以直接访问另一类中的非公有成员。 可以将普通函数、类、类的成员函数声明为友元。 **友元关系是不能传递的。**B类是A类的友元，C类是B类的友元，C类和A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享。 友元关系是单向的，如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有成员和保护成员。但A类的成员不能访问B类的私有成员和保护成员，除非声明A类是B类的友元。 运算符重载为友元函数 1 2 3 4 friend \u0026lt;函数值类型\u0026gt; operator \u0026lt;运算符\u0026gt;(\u0026lt;参数表\u0026gt;) { \u0026lt;函数体\u0026gt;； } 运算符重载为类的友元函数最多只能有两个参数。 如果重载双目运算符，则第一个参数代表左操作数，第二个参数代表右操作数。 当运算符重载为友元函数时，参数中同样必须有一个是用户自定义类型的对象，但不限定其必须是左操作数。 该类型友元函数为普通函数，类内定义。 非友元的运算符重载视为隐含了操作数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class A { int i; public: A(int a=0) { i=a; } void Show(void) { cout\u0026lt;\u0026lt;\u0026#34;i=\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } friend A operator +(A \u0026amp;,A \u0026amp;); //友元函数，两个参数，为引用，这是普通函数 }; A operator +(A \u0026amp;a , A \u0026amp;b) { A t; t.i=a.i+b.i; return t; } int main() { A a1(10),a2(20),a3; a1.Show ( ) ; a2.Show ( ); a3=a1+a2;\t// 相当于 a3=operator+(a1,a2) //重新解释了加法，可以直接进行类的运算 a3.Show ( ); return 0; } 例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Triangle { public: Triangle(int i,int j,int k) { double s; x=i; y=j; z=k; s=(x+y+z)/2.0; area=sqrt(s*(s-x)*(s-y)*(s-z)); } void disparea() { cout\u0026lt;\u0026lt;\u0026#34;Area=\u0026#34;\u0026lt;\u0026lt;area\u0026lt;\u0026lt;endl; } friend double operator+(Triangle \u0026amp;t1, Triangle \u0026amp;t2) //运算符重载为友元函数 { return t1.area+t2.area; } private: int x,y,z; double area; }; int main() { Triangle t1(3,4,5),t2(4,5,6); double s; cout\u0026lt;\u0026lt;\u0026#34;t1:\u0026#34;; t1.disparea(); cout\u0026lt;\u0026lt;\u0026#34;t2:\u0026#34;; t2.disparea(); s=t1+t2; cout\u0026lt;\u0026lt;\u0026#34;总面积=\u0026#34;\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; return 0; } 单目运算符重载为友元函数 1 2 A operator ++( A a ){ .... } A operator ++(A a, int){ .... } 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class A { int i; public: A(int a=0) { i=a; } void Show(void) { cout\u0026lt;\u0026lt;\u0026#34;i=\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } friend A operator++(A \u0026amp;a) { a.i++; retrurn a; } friend A operator++(A \u0026amp;a, int n) { A t; t.i=a.i; a.i++; return t; } } ; int main() { A a1(10),a2,a3; a2=++a1;\t// a2=operator++(a1) a3=a1++;\t// a3=operator++(a1,0) a2.Show( ); a3.Show ( ); return 0; } 重载流输入输出运算符 在C++中允许用户重载运算符“\u0026laquo;”和“\u0026raquo;”，实现对象的输入和输出。重载这两个运算符时，在对象所在的类中，将重载这两个运算符的函数说明为该类的友元函数。\n输入运算符 1 2 3 4 5 // 声明带 friend friend istream\u0026amp; operater \u0026gt;\u0026gt;(istream \u0026amp;, ClassName \u0026amp;); ... // 定义不用带 friend istream \u0026amp; operater \u0026gt;\u0026gt;(istream \u0026amp;is, ClassName \u0026amp;f){…} 第一个参数：是左操作数cin，类istream的引用。 第二个参数：是右操作数，即欲输入对象的引用。 返回值类型：类istream的引用。 1 cin \u0026gt;\u0026gt; a 等同于 operator\u0026gt;\u0026gt;(cin, a); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class incount { int c1,c2; public:incount(int a=0,int b=0) { c1=a; c2=b; } void show(void) { cout\u0026lt;\u0026lt;“c1=”\u0026lt;\u0026lt;c1\u0026lt;\u0026lt;“,”\u0026lt;\u0026lt;“c2=”\u0026lt;\u0026lt;c2\u0026lt;\u0026lt;endl; } // 重载输入函数原型说明 friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;,incount \u0026amp;); }; // 定义 istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is, incount \u0026amp;cc) { is\u0026gt;\u0026gt;cc.c1\u0026gt;\u0026gt;cc.c2; return is; } int main() { incount x1,x2; x1.show ( ); x2.show ( ); cin\u0026gt;\u0026gt;x1; cin\u0026gt;\u0026gt;x2; x1.show ( ); x2.show ( ); return 0; } 输出运算符 1 2 3 friend ostream \u0026amp; operater \u0026lt;\u0026lt;(ostream \u0026amp;, ClassName \u0026amp;); // 对比一下 friend istream \u0026amp; operater \u0026gt;\u0026gt;(istream \u0026amp;, ClassName \u0026amp;); 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class incount { int c1,c2; public:\tincount(int a=0,int b=0) { c1=a; c2=b; } void show(void) { cout\u0026lt;\u0026lt;\u0026#34;c1=\u0026#34;\u0026lt;\u0026lt;c1\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;\u0026#34;c2=\u0026#34;\u0026lt;\u0026lt;c2\u0026lt;\u0026lt;endl; } friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;,incount \u0026amp;); friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;,incount \u0026amp;); } ; istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is,incount \u0026amp;cc) { is\u0026gt;\u0026gt;cc.c1\u0026gt;\u0026gt;cc.c2; return is; } ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,incount \u0026amp;cc)\t//重载cout\u0026lt;\u0026lt; { os\u0026lt;\u0026lt;\u0026#34;c1=\u0026#34;\u0026lt;\u0026lt;cc.c1\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;\u0026#34;c2=\u0026#34;\u0026lt;\u0026lt;cc.c2\u0026lt;\u0026lt;endl; return os; } void main(void) { incount x1,x2; cout\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;x2; //调用输出函数 cin\u0026gt;\u0026gt;x1; //调用输入函数 cin\u0026gt;\u0026gt;x2; cout\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;x2; } 类型转换运算符重载 基本类型 -\u0026gt; 类类型 利用构造函数。\n1 2 3 4 Complex(double r){real=r;imag=0;} // 其作用是将double型的参数r转换成Comlex类的对象，将r作为复数的实部，虚部为0。 Complex c1(3.5); // 建立Complex类对象c1，实部值为3.5，虚部值为0。它的作用就是将double型值转换成一个名为c1的Complex类对象。 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class B { int x; public: B(int a) { x=a; cout\u0026lt;\u0026lt;\u0026#34;调用构造函数\\n\u0026#34;; } ~B( ) { cout\u0026lt;\u0026lt;\u0026#34;调用析构函数\\n\u0026#34;;} void Print( ) {cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl;} }; int main() {\tB b1(1) ; b1.Print( ); b1=10; // b1=B(10)，产生一个临时对象，复制后删除临时对象 b1.Print( ); cout\u0026lt;\u0026lt;\u0026#34;退出主函数n\u0026#34;; return 0; } 类类型 -\u0026gt; 基本类型 利用类型转换运算符重载将A类的对象a转换成某种基本数据类型。\n转换构造函数能够把基本类型数据转换成指定类对象，但不能把类对象转换为基本类型数据。 C++引入一种特殊的成员函数——类型转换函数。类型转换函数实际上就是一个类型转换运算符重载函数。 类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数。 1 2 3 4 5 6 7 8 9 10 11 // 重载类型转换运算符函数格式：函数前不需要加返回值类型 operator〈返回基本类型名〉（）\t// 隐含调用，不需要参数 { …… return 〈基本类型值〉 } operator int () { ... return \u0026lt;int\u0026gt;; } 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A { int i; public: A(int a=0) { i=a; } void Show(void) { cout\u0026lt;\u0026lt;\u0026#34;i=\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } operator int( ) { return\ti; } } ; int main() { A a1(10),a2(20); cout\u0026lt;\u0026lt;a1\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;a2\u0026lt;\u0026lt;endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Complex { double Real,Imag; public: Complex(double real, double imag) { Real=real; Image=imag; } operator double( ); //成员函数，定义类转换 Complex－\u0026gt;double } ; Complex::operator double ( ) { return Real*Real+Imag*Imag; } int main() { Complex c1(3.7,4.5); double d; //隐式调用类型转换函数，c1 -\u0026gt; double，不是运算符重载 d=2.5+c1; cout\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; return 0; } 继承与派生 派生 派生是指由基类创建新类的过程，派生类的定义格式如下。\n1 2 3 class \u0026lt;类名\u0026gt;: \u0026lt;继承方式\u0026gt; \u0026lt;基类名\u0026gt; { \u0026lt;类定义\u0026gt; }; 实例\n1 2 3 4 5 6 7 8 9 class A { int i; //基类成员 }; class B:public A //A派生了B，B继承了A， //B自动拥有A的成员 { int j; //定义派生类的新成员 }; 派生类继承了基类的数据成员和成员函数，它们在派生类中的访问属性由继承方式控制。 类的继承方式有public(公有继承)、protected(保护继承)和private(私有继承)三种。默认情况下为私有继承。 简而言之，基类的私有成员派生类都不可访问。而保护成员和公有成员的访问级别依据继承级别，且级别只能收窄，不能放宽，如公有继承时，基类保护成员仍然为保护级别。\n公有继承 在派生类中，基类的公有成员和保护成员被继承后分别成为派生类的公有成员和保护成员。\n派生类的新成员可以直接访问它们，而派生类的新成员不能直接访问基类的私有成员。在类外，派生类的对象可以访问继承下来的基类公有成员。\n实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Point //基类 { public: //公有成员函数 void InitP(float xx=0,float yy=0) { X=xx; Y=yy ; } void Move(float xOff, float yOff) { X+=xOff; Y+=yOff; } float GetX() { return X; } float GetY() { return Y; } private: //私有数据成员 float X,Y; } ; class Rectangle: public Point//派生类 { public: //新增公有成员函数 void InitR(float x, float y, float w, float h) { InitP(x,y);\t// 调用基类公有成员函数 W=w; H=h; } float GetH() { return H; } float GetW() { return W; } private: //新增私有数据成员 float W, H; }; int main() { Rectangle rect; //声明Rectangle类的对象 rect.InitR(2,3,20,10); //设置矩形的数据 rect.Move(3,2); //移动矩形位置 cout\u0026lt;\u0026lt;\u0026#34;The date of rect(X,Y,W,H):\u0026#34; \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;rect.GetX()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt; rect.GetY()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetW() \u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetH()\u0026lt;\u0026lt;endl; return 0; } 保护继承 在派生类中，基类的公有成员和保护成员全部成为派生类的保护成员。\n派生类的新成员可以直接访问它们，而派生类的新成员不能直接访问基类的私有成员。在类外，派生类的对象不能访问基类的所有成员（都继承为 protected）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Point //基类 { public: //公有成员 void InitP(float xx=0,float yy=0) { X=xx; Y=yy ; } void Move(float xOff, float yOff) { X+=xOff; Y+=yOff; } float GetX() { return X; } float GetY() { return Y; } protected: //保护成员 float X,Y; } ; class Rectangle: protected Point //派生类 { public: //新增外部接口 void InitR(float x, float y, float w, float h) { InitP(x,y); //派生类访问基类成员 W=w; H=h; } void Move( float xOff,float yOff) { Point::Move( xOff, yOff) ; //显式访问基类成员 } float GetX() { return Point::GetX(); } float GetY() { return Point::GetY(); } float GetH() { return H; } float GetW() { return W; } private://新增私有数据 float W, H; }; int main() { Rectangle rect; //声明Rectangle类的对象 rect.InitR(2,3,20,10); //设置矩形的数据 rect.Move(3,2); //移动矩形位置 cout\u0026lt;\u0026lt;\u0026#34;The data of rect(X,Y,W,H):\u0026#34; \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;rect.GetX()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetY()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetW()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetH()\u0026lt;\u0026lt;endl; return 0; } 保护成员具有两面性，对外界（如主函数或非派生类的成员函数）而言是不可见的，但对于它的派生类则是可见的。\n私有继承 在派生类中，基类的公有成员和保护成员全部成为派生类的私有成员。 派生类的新成员可以直接访问它们，而派生类的新成员不能直接访问基类的私有成员。在类外，派生类的对象不能访问基类的所有成员（都继承为 private）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Point //基类 { public: //公有成员 void InitP(float xx=0,float yy=0) { X=xx; Y=yy ; } // Point(float xx=0,float yy=0) // { X=xx; Y=yy ; } void Move(float xOff, float yOff) { X+=xOff; Y+=yOff; } float GetX() { return X; } float GetY() { return Y; } protected: //保护成员 float X,Y; } ; class Rectangle: private Point //派生类 { public: //新增外部接口 void InitR(float x, float y, float w, float h) { InitP(x,y); //派生类访问基类成员 // Point(x,y) 这样是不行，显式调用基类构造函数 W=w; H=h; } void Move( float xOff,float yOff) { Point::Move( xOff, yOff) ; //显式访问基类成员 } float GetX() { return Point::GetX(); } float GetY() { return Point::GetY(); } float GetH() { return H; } float GetW() { return W; } private://新增私有数据 float W, H; } ; int main() { Rectangle rect; //声明Rectangle类的对象 rect.InitR(2,3,20,10); //设置矩形的数据 rect.Move(3,2); //移动矩形位置 cout\u0026lt;\u0026lt;\u0026#34;The data of rect(X,Y,W,H):\u0026#34; \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;rect.GetX()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetY()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetW()\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;rect.GetH()\u0026lt;\u0026lt;endl; return 0; } 派生类的构造函数和析构函数 不能在派生类构造函数体中显示调用基类构造函数来初始化基类成员，所以要通过成员初始化表来完成对基类成员的初始化。\n1 2 3 4 5 6 7 8 \u0026lt;派生类名\u0026gt;(\u0026lt;总参数表\u0026gt;)：\u0026lt;基类名\u0026gt;(\u0026lt;参数表1\u0026gt;)，\u0026lt;对象成员名\u0026gt;(\u0026lt;参数表2\u0026gt;) { \u0026lt;派生类数据成员的初始化\u0026gt; }； Rectangle(float x,float y,float w,float h):Point(x,y){W=w;H=h;} 或: Rectangle(float x,float y,float w,float h):Point(x,y),W(w),H(h){} 构造函数和析构函数的调用顺序 从类Sub11出发，沿继承路径上溯到对应类层次结构分支的顶点（即到达一个没有父类的类），再自上而下地沿该路径逐一调用对应类的constructor，最后调用Sub11的constructor。\n构造函数调用顺序为：基类的构造函数→对象成员构造函数→派生类的构造函数。 析构函数调用顺序刚好相反。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class A { A() { cout \u0026lt;\u0026lt; \u0026#34;A constructor\u0026#34;; } }; class B : A { B():A() { cout \u0026lt;\u0026lt; \u0026#34;B constructor\u0026#34;; } private: C c; }; class C { C() { cout \u0026lt;\u0026lt; \u0026#34;C constructor\u0026#34;; } } int main() { B b; } A constructor\nC constructor\nB constructor\n当基类中没有显式定义构造函数，或定义了无参构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用隐含调用。 当基类的构造函数使用一个或多个参数时，派生类需要定义构造函数，提供将参数传递给基类构造函数的途径。这时，派生类构造函数的函数体可能为空，仅起到参数传递作用。 无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员。 如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class M { friend class N; //N为M的友元，可以直接使用M中的私有成员 private: int i , j; void show( ) { cout\u0026lt;\u0026lt;\u0026#34;i=\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39;\\t\u0026#39;\u0026lt;\u0026lt;\u0026#34;j=\u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#39;\\t\u0026#39;; } public: M(int a=0,int b=0) { i=a; j=b; } } ; class N :public M { //N为M的派生类 public: N(int a=0,int b=0):M(a,b) {} void Print( ) { // 类体内可以直接引用类 M 的私有成员函数和私有成员 show( ); cout\u0026lt;\u0026lt;\u0026#34;i+j=\u0026#34;\u0026lt;\u0026lt;i+j\u0026lt;\u0026lt;endl; } } ; int main( ) { N n1(10,20); M m1(100,200); n1.Print( ); // m1.show( ); n1.show( ); // 私有成员函数，在类外都不可调用 return 0; } 友元关系不能继承。\n多继承与虚基类 当派生类有多个基类时称为多继承。单继承可以看作是多继承的一个特例，多继承可以看作是多个单继承的组合，它们有很多相同特性。\n1 2 3 4 5 // 逗号分隔 class \u0026lt;派生类名\u0026gt;：\u0026lt;继承方式\u0026gt; \u0026lt;基类名1\u0026gt;，…，\u0026lt;继承方式\u0026gt; \u0026lt;基类名n\u0026gt; { \u0026lt;派生类新定义成员\u0026gt; }； 构造函数，同样逗号分隔。\n1 2 3 4 \u0026lt;派生类名\u0026gt;(\u0026lt;总参数表\u0026gt;):\u0026lt;基类名1\u0026gt;(\u0026lt;参数表1\u0026gt;)，…，\u0026lt; 基类名n\u0026gt; (\u0026lt;参数表n\u0026gt;) { \u0026lt;派生类数据成员的初始化\u0026gt; }; 二义性问题 两个基类有同名成员。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class A {public : int a ; void display() ; }; class B {public : int a ; void display() ; }; class C : public A, public B {public : int b ; void show() ; }; ... C c1; c1.a=3;\t// 编译错误 c1.display(); 解决： 添加作用域 c1.A::a=3; c1.A::display(); 两个基类与派生类都有同名：访问的是派生类中的成员，基类的同名成员被屏蔽。 略\n多继承引起二义性问题 C 类会从 A 类和 B 类继承下来两份 N 类的成员。\n虚基类 避免对基类成员访问的二义性问题，可以将直接基类（如A、B）的共同基类（如N）设置为虚基类，这样在继承间接共同基类（N）时只保留一份成员。\n1 class \u0026lt;派生类名\u0026gt;:virtual \u0026lt;继承方式\u0026gt;\u0026lt;共同基类名\u0026gt;; 虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。 引进虚基类后，当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次，也就是说，派生类对象中只存在一个虚基类成员的副本。 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class A { public: A(){a=10;} protected: int a; }; class A1:virtual public A { public: A1(){cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;} }; class A2:virtual public A { public: A2(){cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;} }; class B:A1,A2 { public: B(){cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;} }; int main() { B obj; return 0; } 10 10 10\n构造函数的调用顺序 虚基类的初始化与一般多继承的初始化在语法上相同，但构造函数的调用顺序有所不同，规则如下：\n先调用虚基类的构造函数，再调用非虚基类的构造函数。 若同一层次中包含多个虚基类，其调用顺序为定义时的顺序。 若虚基类由非虚基类派生而来，则仍按先调用基类构造函数，再调用派生类构造函数的顺序。 【存疑】\n虚基类的初始化 如果在虚基类中只定义了带参数的构造函数，则要在其所有派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。\n1 2 3 4 5 6 7 8 class A { A(int i){} … }; class B:virtual public A { B(int n):A(n){}… }; class C:virtual public A { C(int n):A(n){}… }; class D:public B, public C { D(int n):A(n),B(n),C(n){}… }; 习题 写出运行结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class A { public: A(int i, int j) { a=i; b=j; } void move(int x ,int y) { a +=x; b+=y; } void show() { cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } private: int a,b; } ; class B: public A { public: B(int i,int j, int k, int l):A(i,j),x(k),y(l) { } void show() { cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } void fun() { move(3,5); } void f1() { A::show(); } private: int x,y; } ; int main() { A aa(1,2); aa.show(); B bb(3,4,5,6); bb.fun(); bb.A::show(); bb.B::show(); bb.f1(); return 0; } (1,2) (6,9) 5,6 (6,9)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class base { int n; public: base(int a) { cout\u0026lt;\u0026lt;\u0026#34;constructing base class\u0026#34;\u0026lt;\u0026lt;endl; n=a; cout\u0026lt;\u0026lt;\u0026#34;n=\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; } ~base() { cout\u0026lt;\u0026lt;\u0026#34;destructing base class\u0026#34;\u0026lt;\u0026lt;endl; } } ; class base1 { int m; public: base1(int a) { cout\u0026lt;\u0026lt;\u0026#34;constructing base1 class\u0026#34;\u0026lt;\u0026lt;endl; m=a; cout\u0026lt;\u0026lt;\u0026#34;m=\u0026#34;\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; } ~base1() { cout\u0026lt;\u0026lt;\u0026#34;destructing base1 class\u0026#34;\u0026lt;\u0026lt;endl; } } ; class subs:public base { base bobj; base1 bobj1; int x; public: subs(int a, int b, int c, int d) :base(a),bobj1(b),bobj(c) { cout\u0026lt;\u0026lt;\u0026#34;constructing sub class\u0026#34;\u0026lt;\u0026lt;endl; x=d; cout\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; } ~subs() { cout\u0026lt;\u0026lt;\u0026#34;destructing sub class\u0026#34;\u0026lt;\u0026lt;endl; } } ; int main() { subs s(1,2,3,4); return 0; } constructing base class n=1 constructing base class n=3 constructing base1 class m=2 constructing sub class x=4 destructing sub class destructing base1 class destructing base class destructing base class\n多态与虚函数 类型兼容规则 需要基类对象的任何地方，都可以使用公有派生类的对象来替代。\n派生类对象可以赋值给基类对象。 派生类对象可以初始化基类引用。 派生类对象的地址可以赋值给基类的指针变量。 1 2 3 4 class A{…}; class B:public A{…}; A a, *pa; B b; 派生类对象可以赋值给基类对象。即用派生类对象中从基类继承来的成员，逐个赋值给基类对象的成员。\n1 a=b; 只能用派生类对象对其基类对象赋值，而不能用基类对象对其派生类对象赋值。 同一基类的不同派生类对象之间也不能赋值。 派生类对象可以初始化基类引用。\n1 A \u0026amp;a1=b; 派生类对象的地址可以赋值给基类的指针变量。\n1 pa=\u0026amp;b; 对象只能调用转换后类型中定义的函数。\n1 2 3 4 5 6 7 8 9 BaseClass baseObject; DerivedClass derivedObject; baseObject=derivedObject; derivedObject.derivedFun(); // y derivedObject.baseFun(); // y baseObject.baseFun(); // y baseObject.derivedFun(); // n 多态 调用同一个函数名，可以根据需要实现不同的功能。\n静态多态性：在程序编译时系统就能决定调用的是哪个函数。又称为编译时的多态性。静态多态性是通过函数的重载实现的（包括运算符重载）。 动态多态性：在程序运行过程中才动态地确定操作所针对的对象。又称为运行时的多态性。动态多态性是通过虚函数实现的。 1 2 3 4 5 6 Base b; Sub d; Base *basep = \u0026amp;b; basep -\u0026gt; show();\t// 调用基类的 show basep = \u0026amp;d; basep -\u0026gt; show();\t// 调用的还是基类继承的 show basep 只能访问从基类继承来的成员。\n利用运行时多态，将基类的 show 定义为虚函数，这样 basep 就可以指向派生类新增的成员函数。\n虚函数 基类中被关键字 virtual 修饰，在一个或多个派生类被重新定义的成员函数。\n1 virtual \u0026lt;返回值类型\u0026gt; \u0026lt;函数名\u0026gt; \u0026lt;(参数表)\u0026gt; 虚函数实现的动态多态：同一类族中不同类的对象，对同一函数调用做出不同的响应。\n类之间应满足类型兼容规则。 同名声明虚函数。 通过指针、引用来访问虚函数。 在程序运行时，不同类的对象调用各自的虚函数，就是动态多态。\n一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。\n虚函数声明与实现分开时，virtual 只需要用在声明。 1 2 3 4 5 6 7 8 9 class Student { public: virtual void print(); //虚函数的声明 }; void Student::print() //虚函数的实现 cout\u0026lt;\u0026lt;\u0026#34;A student\u0026#34;\u0026lt;\u0026lt;endl;\t} 在派生类中重新定义虚函数时，其函数原型包括返回类型、函数名、参数个数、类型和顺序，都必须与基类中的原型相同。\n一个类中的虚函数说明只对派生类中重定义的函数有影响，对它的基类中的函数并没有影响。\n构造函数不能是虚函数。\n析构函数可以是虚函数。\n当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，**与虚函数同名的重载函数覆盖了派生类中的虚函数。**此时试图通过派生类对象、指针、引用调用派生类的虚函数就会产生错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Point { private: int X,Y ; public: Point(int X=0,int Y=0) { this-\u0026gt;X=X,this-\u0026gt;Y=Y; } virtual double area() //求面积 { return 0.0; } } ; const double PI=3.14159; class Circle :public Point { private: double radius; //半径 public: Circle(int X, int Y, double R):Point(X,Y) { radius=R; } double area() //求面积 { return PI*radius*radius; } double area(int i) // 如果没有定义 area()，会覆盖虚函数，基类不可见 area(i)，派生类不可见 area() { return PI*radius*radius; } } ; int main() { Point P1(10,10); cout\u0026lt;\u0026lt;\u0026#34;P1.area()=\u0026#34;\u0026lt;\u0026lt;P1.area()\u0026lt;\u0026lt;endl; Circle C1(10,10,20); cout\u0026lt;\u0026lt;\u0026#34;C1.area()=\u0026#34;\u0026lt;\u0026lt;C1.area()\u0026lt;\u0026lt;endl; Point *Pp; Pp=\u0026amp;C1; cout\u0026lt;\u0026lt;\u0026#34;Pp-\u0026gt;area()=\u0026#34;\u0026lt;\u0026lt;Pp-\u0026gt;area()\u0026lt;\u0026lt;endl; Point \u0026amp; Rp=C1; cout\u0026lt;\u0026lt;\u0026#34;Rp.area()=\u0026#34;\u0026lt;\u0026lt;Rp.area()\u0026lt;\u0026lt;endl; return 0; } 如果在派生类中没有重新定义虚函数，则不实现动态多态，派生类的对象将使用基类的虚函数代码。 纯虚函数与抽象类 纯虚函数 纯虚函数用virtual声明，没有任何实现、必须由派生类重新定义该函数提供实现 纯虚函数的声明格式为：\nvirtual \u0026lt;函数值类型\u0026gt; \u0026lt;函数名\u0026gt;(\u0026lt;参数表\u0026gt;)=0; 纯虚函数不需要定义实现方法，它的存在只是为了在派生类中被重新定义，只是为了提供一个多态的接口。\n抽象类 包含一个或多个纯虚函数的类称为抽象类。\n如果派生类没有实现基类中的所有纯虚函数，派生类也是抽象类。\n抽象类无法实例化，即不能创建抽象类的对象。\n抽象类不能用作参数类型、函数值类型或显式转换的类型，但可以声明指向抽象类的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态。\n纯虚函数与函数体为空的虚函数 区别： 前者没有函数体,而后者有函数体； 前者所在的类是抽象类,不能直接进行实例化,而后者所在的类是可以实例化的。 共同点： 这两类函数所在的类都可以派生出新的类，然后在新类中给出虚函数新的实现，而且这种新的实现可以具有多态特征。 习题 找出错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;iostream\u0026gt; using namespace std; class B { public: void print() { cout\u0026lt;\u0026lt;\u0026#34;B class\u0026#34;\u0026lt;\u0026lt;endl; } } ; class D1:public B { public: void print() { cout\u0026lt;\u0026lt;\u0026#34;D1 class\u0026#34;\u0026lt;\u0026lt;endl; } } ; class D2: B { public: void print() { cout\u0026lt;\u0026lt;\u0026#34;D2 class\u0026#34;\u0026lt;\u0026lt;endl; } } ; int main() { B obj1,*p; D1 obj2; D2 obj3; obj1=obj2;\t//（A） obj2.B::print();\t//（B） p=\u0026amp;obj2;\t//（C） p-\u0026gt;print(); p=\u0026amp;obj3;\t//（D） p-\u0026gt;print(); return 0; } D：缺省继承为 private 继承，基类指针/引用不能指向protected与private的派生类对象。\n私有继承为 has-a 的关系，共有继承为 is-a 的关系，因此不能用基类指针指向私有继承的派生类对象。（我只是包含了你，我并不属于你，你不能代表我）\n实现层面来说，在派生类的对象空间中基类的对象，只是无法让其公开访问。如果为 private 继承，这个基类对象就无法通过派生类对象访问，因此也就无法指向了。\n写出运行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;iostream\u0026gt; using namespace std; class Point { public: Point(int x1,int y1) { x=x1; y=y1 ; } int area() const { return 0; } private: float x,y; } ; class Rect: public Point { public: Rect(int x1, int y1, int u1, int w1):Point(x1,y1) { u=u1; w=w1; } int area() const { return u*w; } private: int u, w; } ; void fun(Point \u0026amp;p) { cout\u0026lt;\u0026lt;p.area()\u0026lt;\u0026lt;endl; } int main() { Rect rec(2,4,10,6); fun(rec); return 0; } 0\n将Point类的area()函数定义为虚函数，其运行结果是什么？\n60\n输入输出流 Stream 流（stream）是指数据从一个位置流向另一个位置。流是字节的序列。\n输入／输出是一种数据传递操作，可以看作字符序列在计算机内存与外设之间的流动，C++将数据从一个对象到另一个对象的流动抽象为“流”。流动的方向不同，构成输入/输出流，即I/O流。\n从流中获取数据的操作称为提取操作。 向流中添加数据的操作称为插入操作。 IO流类库的层次结构 平行基类\nstreambuf ios ios 类的层次结构\n无格式输入输出 无格式输入/输出就是按系统预定义的格式进行的输入/输出。 按默认约定，每个C++程序都能使用标准I/O流，如标准输入、标准输出。 即 iostream。\n无格式输入 cin\n无格式输出 cout\n输入输出格式控制 C++提供了两种格式化输入/输出方式:\n一种是用流对象的有关成员函数进行格式化输入输出 另一种是用专门的控制符进行格式化输入输出 成员函数进行格式化输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void showflags(long f); int main() { long f; f=cout.flags(); //取当前状态标志 showflags(f);\t// 0000001000000001 //显示状态值 cout.setf(ios::showpos|ios::scientific|ios::fixed); //追加状态标志 f=cout.flags(); //取当前状态标志 showflags(f);\t// 0011001000100001 //显示状态值 cout.unsetf(ios::scientific); //从状态标志中去掉 scientific f=cout.flags(); //取当前状态标志 showflags(f);\t// 0010001000100001 //显示状态值 f=cout.flags(ios::hex); //重新设置状态标志 showflags(f);\t// 0010001000100001 f=cout.flags(); //取当前状态标志 showflags(f); return 0; } void showflags(long f) { long i; for (i=0x8000;i;i=i\u0026gt;\u0026gt;1) //用右移方式使i中的值为\u0026#34;1\u0026#34;的位不断右移 if(i\u0026amp;f)cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;; //判断f中的某一位是否为\u0026#34;1\u0026#34; 设置输出宽度 1 2 int ios::width(int len) int ios::width() 设置填充字符 1 2 char ios::fill(char ch) char ios::fill() 设置输出精度 1 2 int ios::precision(int p) int ios::precision() 实例\n1 2 3 4 5 6 7 int main() { cout.width(15); cout.fill(\u0026#39;*\u0026#39;); cout.precision(8); cout\u0026lt;\u0026lt;123.456789\u0026lt;\u0026lt;\u0026#34;(example)\u0026#34;\u0026lt;\u0026lt;endl; } // ******123.45679(example) put 输出字符 必须是 char，否则 ascii -\u0026gt; char\n1 2 3 cout.put(‘a’); cout.put(97); cout.put(71).put(79); get 读入字符 返回值就是读入的字符。若遇到输入流中的文件结束符，则函数返回文件结束标志EOF。\n1 cin.get(); 含参：\n读取成功返回非0值（真），如失败（遇文件结束符）则函数返回0值（假）。\n1 cin.get(ch);\t// cin \u0026gt;\u0026gt; ch 三参数：\ncin.get(字符数组/字符指针，字符个数n，终止字符)\n从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组）。 如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束。 如果读取成功返回非0值（真），如失败（遇文件结束符）则函数返回0值（假）。 1 2 3 4 5 6 7 8 9 10 int main() { char ch[20]; cout\u0026lt;\u0026lt;\u0026#34;enter a sentence:\u0026#34;\u0026lt;\u0026lt;endl; cin.get(ch,10,\u0026#39;/\u0026#39;); cout\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; cin.get(ch,20,‘\\n’); //指定换行符为终止字符 cout\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; return 0; } enter a sentence: you!/her. you! /her.\ngetline 读入一行字符。\n1 cin.getline(char[], n, \u0026#39;\\n\u0026#39;); 实例\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { char ch[20]; cout\u0026lt;\u0026lt;\u0026#34;enter a sentence:\u0026#34;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;ch;\t// cin 遇到空格停止 cout\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; cin.getline(ch,20,\u0026#39;/\u0026#39;);\t// \u0026#39;/\u0026#39; 为分隔符 cout\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; cin.getline(ch,20);\t// 读够 20 个字符 cout\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; return 0; } enter a sentence: I like C++./I study C++./I am happy. I like C++. I study C++./I am h\neof 从输入流读取数据，如果到达文件末尾（遇文件结束符），返回非零值（真），否则为0（假）。\n1 while (!cin.eof()) {...} peek 返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移。 如果要访问的字符是文件结束符，则函数值是EOF。\nputback 将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，以供后面读取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { char c[20]; int ch; cout\u0026lt;\u0026lt;\u0026#34;enter a sentence:\u0026#34;\u0026lt;\u0026lt;endl; cin.getline(c,15,\u0026#39;/\u0026#39;); cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; ch=cin.peek(); //观看当前字符 cout\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; cin.putback(c[0]); //将‘I’插入到指针所指处，会替换掉原有的 \u0026#39;/\u0026#39; cin.getline(c,15,\u0026#39;/\u0026#39;); cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } enter a sentence: I am a boy./ am a student./ I am a boy. 32 I am a student\nignore cin.ignore(n,终止字符) 跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）。 ignore（5，’A’）;//跳过5个字符，遇’A’后不再跳\n1 2 3 4 5 6 7 8 9 10 int main() { char ch[20]; cin.get(ch,20,\u0026#39;/\u0026#39;); cout\u0026lt;\u0026lt;“The first part is:”\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; cin.ignore(); //跳过输入流中一个字符 cin.get(ch,20,\u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt;“The second part is:”\u0026lt;\u0026lt;ch\u0026lt;\u0026lt;endl; return 0; } I like C++./I study C++./I am happy. The first part is:I like C++. The second part is:I study C++.\n控制符格式化 setw(int) 设置输入/输出域的宽度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { char *p=\u0026#34;12345\u0026#34;,*q=\u0026#34;678\u0026#34;; char f[4],g[4]; int i=10; cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;setw(6)\u0026lt;\u0026lt;q\u0026lt;\u0026lt;setw(4)\u0026lt;\u0026lt;p\u0026lt;\u0026lt;q\u0026lt;\u0026lt;endl; //设置输出宽度 cin\u0026gt;\u0026gt;setw(4)\u0026gt;\u0026gt;f\u0026gt;\u0026gt;g; //设置输入宽度 cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;g\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;i:\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } 12345 67812345678 12345 123 45 i:10\nsetfill(char) 设置后直至下一次设置前一直有效\nsetprecision(int) 参数为 0 时，默认有效位数 6 输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double values[]={1.23,35.36,653.7,4358.24}; char *names[]={\u0026#34;Zoot\u0026#34;,\u0026#34;Jimmy\u0026#34;,\u0026#34;Al\u0026#34;,\u0026#34;Stan\u0026#34;}; for(int i=0;i\u0026lt;4;i++) cout\u0026lt;\u0026lt;setiosflags(ios::left) //设置左对齐 \u0026lt;\u0026lt;setw(6)\u0026lt;\u0026lt;names[i] \u0026lt;\u0026lt;resetiosflags(ios::left) //取消左对齐，含宽度则默认右对齐 \u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;values[i] \u0026lt;\u0026lt;endl; return 0; } Zoot 1.23 Jimmy 35.36 Al 653.7 Stan 4358.24\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double f=22.0/7; //在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数 cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //默认有效位数为6 cout\u0026lt;\u0026lt;setprecision(3)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //设置有效位数为3 //在用定点形式表示的输出中，setprecision(n)表示实数的小数位数 cout\u0026lt;\u0026lt;setiosflags(ios::fixed); cout\u0026lt;\u0026lt;setprecision(8)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //小数位数为8 cout\u0026lt;\u0026lt;setprecision(8); cout\u0026lt;\u0026lt;setiosflags(ios::scientific)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //尾数小数位数为8 return 0; } 3.14286 3.14 3.14285714\n用户自定义控制符函数 输出\n1 2 3 4 ostream\u0026amp; manip_name（控制符函数名）(ostream\u0026amp; stream) { \u0026lt;自定义语句序列\u0026gt; return stream; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; ostream\u0026amp; setup(ostream\u0026amp; stream) { stream.setf(ios::left); stream\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;setfill(\u0026#39;$\u0026#39;); return stream; } int main() { cout\u0026lt;\u0026lt;10\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;setup\u0026lt;\u0026lt;10\u0026lt;\u0026lt;endl; return 0; } 10 10$$$$$$$$\n输入\n1 2 3 4 5 istream\u0026amp; manip_name(istream\u0026amp; stream) { \u0026lt;自定义语句序列\u0026gt; return stream; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; istream\u0026amp; prompt(istream\u0026amp; stream) { cin\u0026gt;\u0026gt;hex;\t// 十六进制格式输入 cout\u0026lt;\u0026lt;\u0026#34;Enter number using hex format：\u0026#34;; return stream; } int main() { int i; // 函数不需要传参 cin\u0026gt;\u0026gt;prompt\u0026gt;\u0026gt;i; cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } 文件流 在涉及文本文件的操作时，将输入文件看成键盘，将输出文件看成显示器，格式不变。只需在程序中增加打开与关闭文件的语句\n一般步骤 为文件定义一个流类对象； 使用open()函数建立（或打开）文件。如果文件不存在，则建立该文件；如果磁盘上已存在该文件，则打开该文件； 进行读写操作。在建立（或打开）的文件上执行所要求的输入/输出操作。一般来说，在内存与文件的数据传输中，由内存到文件称为输出或写，反之则称为输入或读； 使用close()函数关闭文件。当完成操作后，应把打开的文件关闭，避免误操作。 实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; int main() { // 1 ofstream ostrm; //定义流类对象 ostrm.open(\u0026#34;f1.dat\u0026#34;); //打开文件 ostrm\u0026lt;\u0026lt;120\u0026lt;\u0026lt;endl; //写操作 ostrm\u0026lt;\u0026lt;310.85\u0026lt;\u0026lt;endl; ostrm.close(); //关闭文件 // 2 ifstream istrm(\u0026#34;f1.dat\u0026#34;); //定义流类对象 // 3 // fstream istrm(\u0026#34;file name\u0026#34;, ios::in); int n; double d; istrm\u0026gt;\u0026gt;n\u0026gt;\u0026gt;d; //读操作 cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; istrm.close(); //关闭文件 return 0; } 二进制文件读写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 struct person { char name[20]; double height; unsigned short age; } people[3]= { \u0026#34;wang\u0026#34;,1.65,25, \u0026#34;zhang\u0026#34;,1.78,24, \u0026#34;li\u0026#34;,1.85,21 } ; int main() { fstream infile,outfile; outfile.open(\u0026#34;exam.dat\u0026#34;,ios::out|ios::binary); // 二进制写 if(!outfile) { cout\u0026lt;\u0026lt;\u0026#34;exam.dat can\u0026#39;t open\u0026#34;\u0026lt;\u0026lt;endl; abort(); } for (int i=0;i\u0026lt;3;i++) // (char*) 取 people[i] 的地址并强转为 (char*) outfile.write((char*)\u0026amp;people[i],sizeof(people[i])); outfile.close(); infile.open(\u0026#34;exam.dat\u0026#34;,ios::in|ios::binary); if(!infile) { cout\u0026lt;\u0026lt;\u0026#34;exam.dat can\u0026#39;t open\u0026#34;\u0026lt;\u0026lt;endl; abort(); } for (int j=0;j\u0026lt;3;j++) { infile.read((char*)\u0026amp;people[j],sizeof(people[j])); cout\u0026lt;\u0026lt;people[j].name\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;people[j].height\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;people[j].age\u0026lt;\u0026lt;endl; } infile.close(); return 0; } 文件的随机读写 移动读指针\n1 2 3 istream\u0026amp; istream::seekg(streampos pos); // p -\u0026gt; pos istream\u0026amp; istream::seekg(streamoff offset,seek_dir origin); // 该函数的功能是从origin指定的开始位置起，将文件指针移动offset个字节数 其中，origin的类型seek_dir是一个枚举类型，有以下三种取值：\nios::beg 表示指针的起始位置为文件头 ios::cur 表示指针的起始位置为当前位置 ios::end 表示指针的起始位置为文件尾 返回读指针当前位置。\n1 streampos istream::tellg( ); 写指针也有相关函数。\n1 2 3 4 5 6 // 移动写指针函数 ostream\u0026amp; ostream::seekp(streampos pos); ostream\u0026amp; ostream::seekp(streamoff offset,seek_dir origin); // 返回写指针当前指向的位置值 streampos ostream::tellp( ); // 函数参数的意义与读指针函数一样 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { fstream file(\u0026#34;exam.dat\u0026#34;,ios::in|ios::out|ios::binary); if(!file) { cout\u0026lt;\u0026lt;\u0026#34;exam.dat can’t open\u0026#34;\u0026lt;\u0026lt;endl; abort(); } for (int i=0;i\u0026lt;15;i++) file.write((char*)\u0026amp;i,sizeof(int)); streampos pos=file.tellp();\t// 写指针 wp 位置 cout\u0026lt;\u0026lt;\u0026#34;current byte number: \u0026#34;\u0026lt;\u0026lt;pos\u0026lt;\u0026lt;endl;\t// 4*15 = 60 for (i=15;i\u0026lt;45;i++) file.write((char*)\u0026amp;i,sizeof(int)); file.seekg(pos);\t// 重设读指针 rp = 60 file.read((char*)\u0026amp;i,sizeof(int)); cout\u0026lt;\u0026lt;\u0026#34;The data stored is \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\t// 15 file.seekp(0,ios::beg);\t// 重设写指针 文件头 for (i=80;i\u0026lt;100;i++) file.write((char*)\u0026amp;i,sizeof(int));\tfile.seekg(pos);\t// 重设读指针 rp = 60 file.read((char *)\u0026amp;i,sizeof(int));\tcout\u0026lt;\u0026lt;\u0026#34;The data stored is \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\t// 95 file.seekp(20,ios::cur);\t// 写指针向右偏移 20bit file.read((char *)\u0026amp;i,sizeof(int));\t// cout\u0026lt;\u0026lt;\u0026#34;The data stored is\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;current byte number: \u0026#34;\u0026lt;\u0026lt;file.tellp()\u0026lt;\u0026lt;endl; // 写指针位置 return 0; } 字符串流 ","date":"2022-03-11T12:00:19Z","image":"https://TuJin07.github.io/p/c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/cover_hu60a335ca4c55178541a8b7f6f0b682b3_1463971_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/","title":"C++程序设计课程总结"},{"content":"微机原理与接口技术 本笔记基于 CS Lee\u0026rsquo;s Notes，提取记录其中一些个人认为的重点、考点以及需要记忆的点，供重复翻看。\nIntel 单核处理器 8086 寄存器结构 段寄存器 寄存器的作用如其名，唯一值得注意的是附加段寄存器。默认访问数据采用 DS，需要跨段访问数据时，指定 ES 来访问数据。\n1 MOV\tAX,\tES:[BX] 数据寄存器 一般随便用，用于存储数据。记记几个特殊作用。\nAX：某些指令如乘法指令，包含隐含寻址（默认乘数在 AX），抑或是最后结果存放在 AX 等。 BX：可以用作指针寄存器，配和 DS 作为默认段寄存器。 CX：用于 LOOP 指令循环时 CX 记录剩余循环次数。 四者都可以拆分成两个 8bit 寄存器使用，如 AX 可以拆为 AL与 AH。 控制寄存器 IP 用于寄存下一条指令的内存地址，结合 CS（代码段寄存器）实现代码段的寻址。\n标志寄存器下面单独讲。\n指针寄存器 \u0026amp; 变址寄存器 SP 标记栈顶位置，结合 SS（堆栈段寄存器）共同维护堆栈，实现栈顶的寻址以及出入栈操作。\nBP 同样用来访问栈，与 SP 固定指向栈顶不同，用来随机访问栈中任意元素。\n8086 中的栈\n栈顶小地址，栈底大地址，记忆上可以想象成一个高塔形状，必然是顶小底大才能稳。\n16bit 的 CPU，栈中每个数据都为 16bit。\nSI 与 DI 都用来访问一般的数据，默认寄存器 DS。结合上文所说的 BX，这三者可以通过间接寻址对内存的数据段进行访问。\nSI 与 DI 这两个寄存器名字分别为源变址寄存器与目的变址寄存器，只是为了程序员编程时方便分类使用，如源数据指针采用 SI，目的数据指针采用 DI，实际作用上二者没有本质区别，怎么用都可以。\n标志寄存器 这里只挑几个重要的记录下。\n运算结果相关 CF，Carry Flag，加法中最高位有向更高位进位，或减法中最高位有向更高位借位，置 1 。 PF，Parity Flag，奇偶标志位，结果中 1 为偶数个置 1 。 SP，Sign Flag，符号标志位，映射结果最高位。 ZF，Zero Flag，结果为 0 置为 1 。 OF，Overflow，运算结果溢出置为 1 ，对于有符号数，OF = C~n~ XOR C~n-1~。 1 2 3 4 5 6 7 8 9 10 11 mov al,\t+127 add al,\t1 ; OF = 1 mov al,\t-128 sub al,\t1 ; OF = 1 mov al,\t-128 ; AL = 10000000b neg al ; AL = 10000000b, OF = 1 mov al,\t+127 ; AL = 01111111b neg al ; AL = 10000001b, OF = 0\t这里是 0，lsc标错 运算结果无关 IF，中断允许标志位，开中断为 1 。 双体内存 8086 采用双体内存结构。其地址线共计 A~0~ ~ A~19~ 合 20 根，以满足最大 1MByte 的内存寻址。\n1MB = 2^20^Byte，以字节为基本单元，需要 20bit 来存储所有的地址可能。\n双体内存结构中，以字（16bit）作为基本单元，只需要 19bit 来存储所有地址可能。因此，采用 A~1~ ~ A~19~ 作为字的地址寻址，A~0~ 结合 !BHE（编辑所限，!指代上划线。）作为奇偶存储体选择信号。\nA~0~ !BHE 选中存储体 功能 0 0 奇偶存储体 读 16bit 的对齐数据 0 1 偶存储体 读 8bit 的数据 / 16bit 的非对齐数据的前 8bit 1 0 奇存储体 读 8bit 的数据 / 16bit 的非对齐数据的后 8bit 数据对齐\n举个例子，16bit 的数据在内存中存储，起始存储单元为偶数地址单元则为数据对齐，占用一个总线周期可以完成读写；反之，需要通过两个总线周期。\n8086 引脚 地址线与数据线复用\n8086 中，地址线与数据线是复用的。低 16 位地址线与 16 位数据线复用，高 4 位地址线与状态信号复用。\n中断信号线\n这是一类引脚，分为三条线。\nNMI，不可屏蔽中断请求输入引脚。 INTR，可屏蔽中断请求输入引脚。 !INTA，中断应答引脚（最小模式）。 在后面讲到 8259 的时候还会说到。\n中断工作过程\n中断向量：每一个中断源有的唯一标识，一个 8bit 的编号。由于 8bit 最多有 256 种组合，因此 8086 可以管理至多 256 个中断源。\n中断向量表：注意，这不是存放中断向量的表，这是保存中断后对应中断向量的处理程序位置的表。该表有 0 ~ 255 行，合 256 行，分别对应 256 个中断向量对应的处理程序位置。每一行占 4 Byte，记录中断处理程序的地址。前两个 Byte 表示段内偏移，后两个 Byte 表示段地址。\nCPU 需要执行中断时，首先保护现场，然后获得中断向量，根据此向量去查中断向量表，获取对应的中断程序地址，置于 PI 与 CS 寄存器内，开始处理中断程序。\n执行读操作的周期分布\n一般认为，忽略等待周期的情况下，执行一次读操纵需要 4 个 CPU 周期。\nT~1~：CPU 送地址至总线，稳定后 ALE 脉冲，告知有地址已稳定。 T~2~：CPU 送 RD 信号，内存读入地址，寻找对应数据。 T~3~：CPU 切换读数据模式，等待内存返回数据。 T~4~：内存送数据至总线，CPU 读入数据。 最小模式与最大模式\n最小模式可以令 8086 独立工作运行。最大模式可以结合其他芯片器件运行。\n最小模式下 CPU 的引脚接线（看懂就好，不用记） 最大模式下 CPU 的引脚接线（看懂就好，不用记） 74373：单向锁存器\n74245：双向锁存器\n汇编 汇编程序基础模板\n借助个简要的模板，讲解下汇编代码的编写范例以及各字段作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 STACK SEGMENT STACK\t; 堆栈段定义 DB 500 DUP(0)\t; 定义500个Byte的空间（Define Byte），初始化为0 STACK ENDS DATA SEGMENT\t; 数据段定义 .......\t; 数据定义 DATA ENDS CODE SEGMENT\t; 代码段定义 ASSUME CS:CODE,DS:DATA,ES:DATA,SS:STACK\t; 这段是告诉编译器的，数据段还是要自己初始化 START:\tMOV AX,DATA\t; 程序入口需要一个标记，这里是“start”，结尾要接 END START MOV DS,AX\t; 这两行固定用来指定数据段 .......\t; 主程序代码 MOV AH,4CH INT 21H\t; 这两行用来关闭程序 CODE ENDS END START\t; 整个程序最后，用END后面指明程序入口点的位置 考试中应该不用你编写完整一个汇编程序（如果要的话当我没说），但基本的结构还是要了解的，也并不困难，框架就如上所示。\n汇编中的算数运算符号\n你在汇编程序中，是可以直接写算术符号的。\n这些算术符号并不会在编译后产生对应的汇编指令，编译器会帮你直接计算出结果，作为一个立即数的形式放到程序中。\n数据类型\n主要记住 DB，DW，DD 三种常见的即可。\nPTR 操作符\n用于不同的数据类型间转换。看懂下面的代码就可以，我认为应该不会考。\n1 2 3 4 5 6 7 .data myDouble DWORD 12345678h .code mov ax,myDouble ;错误 mov ax,WORD PTR myDouble ;ax = 5678h，取出低 16bit，小端存储 mov ax,WORD PTR [myDouble+2] ;ax = 1234h mov bl,BYTE PTR myDouble ;bl = 78h 汇编中的常见指令 MOV 1 MOV\tAX,\tDATA 天天用，注意几点即可。\n操作数尺寸一致，源是 16bit，目的也必须为 16bit。 两个操作数不能同时为内存操作数。 XCHG 交换两个操作数内容，用的不多。\n1 XCHG AX, BX 同样，两个操作数不能同时为内存操作数。\nADD AX + VAR -\u0026gt; AX，结果存放在目的操作数中（即本例中的 AX）。\n1 ADD\tAX,\tVAR SUB AX - VAR -\u0026gt; AX\n1 SUB AX, VAR NEG -AX -\u0026gt; AX，求负，将操作符认为是一个补码，按位取反末位加一。\n1 NEG AX JMP 无条件跳转。\nLOOP 执行 LOOP 指令前，**先对 CX 执行 -1，再判断 CX 是否为 0。**为零则结束循环。\n汇编中的过程定义与使用（函数） 过程的定义\n以如下模板定义一个过程。\n1 2 3 4 5 SumOf PROC\t; SumOf是你的过程名，注意过程没有传入的参数 add eax,ebx\t; 主代码 add eax,ecx ret\t; return，过程结束前必要 SumOf ENDP\t; 过程结束 其实主函数本质上也是一个特殊过程。\n例子：对整数数组求和\n过程本体\n1 2 3 4 5 6 7 8 9 10 11 12 ArraySum PROC push esi ; 保护寄存器ESI与ECX，压入栈中，ESI执行数组首地址 push ecx mov eax,0 ; 设定EAX作为SUM，初始值置为0 L1:\tadd eax,[esi] ; 将ESI所指数组项加入到SUM add esi,4 ; 32bit 的汇编程序，一个整数占 32bit，所以移动到下一个元素需要 + 4 loop L1\t; 循环直至遍历结束数组（ECX = 0时） pop ecx ; 恢复现场 pop esi ret\t; 返回，结果保存在 EAX ArraySum ENDP 在 main 中调用该过程\n1 2 3 4 5 6 7 8 9 10 .data array DWORD 10000h,20000h,30000h,40000h,50000h theSum DWORD ? .code main PROC mov esi, OFFSET array ; ESI初始化指向array首地址 mov ecx, LENGTHOF array ; ECX初始化为数组长度 call ArraySum\t; 调用过程 mov theSum,eax ; 用theSum存储返回在EAX中的结果 ...... 寻址方式 这里就直接按老师给的题目讲，掌握了就差不多了。\n题目 一 立即寻址，@DATA 在编译时会被编译器替换成对应地址的立即数。 直接寻址，变量如 ARRAY 在编译时会替换成所指向的地址，通过 \u0026lsquo; \u0026rsquo; 表示取该地址对应的数据，为直接寻址。 直接寻址。 立即寻址，OFFSET 在编译时就会被替换成对应地址的立即数。 立即寻址。 寄存器间接寻址，[寄存器] 表示取内存中寄存器存的对应地址的变量。 立即寻址，注意数据段的定义，ARRAYSIZE 不是定义的变量，而是“等号伪指令”，在编译过程中就会被编译器替换为对应的数值。 直接寻址，同 \u0026lsquo;2\u0026rsquo;。 寄存器相对寻址，ARRAY[SI] 也可以表示为 [ARRAY + SI]，在 ARRAY 所指地址的基础上加上寄存器 SI 的偏移，共同构成目的地址，称为寄存器相对寻址。 PC 相对寻址。 题目 二 立即寻址。 寄存器寻址，直接用的寄存器内的值。 寄存器间接寻址，寄存器内的值用作地址量，取内存中对应地址的值。 直接寻址，TABLE 编译后转化为内存中的对应地址。 寄存器相对寻址。 寄存器相对寻址。 补充\n这个东西不常见，了解下，知道原理即可。\n基址变址寻址 一般用在二维数组，通过两个寄存器值相加（基址寄存器与变址寄存器）产生偏移地址。\n相对基址变址寻址 也用在二维数组，和上一个的区别在于通过数组 tableB， 再添加一个偏移量，进行访问。\n条件处理 讲条件比较指令之前，简单说一下几条逻辑运算指令。比较指令就是在此基础上建立的。注意以下指令结果会会送到目的操作数，即例子中的 AL。\n逻辑运算 AND\n按位与，主要用于特定位清零，其余位保留。\n1 AND\tAL,\t00000011b\t; 只保留AL低两位 OR\n按位或，特定位置一，其余位保留。\n1 OR\tAL,\t11000000b\t; 高两位置1 XOR\n异或，同为假异为真。\n1 XOR\tAL,\tBL NOT\n非，按位取反，即求反码。\n1 NOT\tAL 比较指令 比较指令不会回送目标操作数，但会改变对应标志位的结果。\nTEST\n功能与 AND 类似，不回送结果。常和 JZ 或 JNZ 搭配。\n1 2 TEST AL, 00001001b\t; 测试0位和3位是否同时为0 JZ\tC1\t; 结果为0，表明0位和3位同时为0，跳转C1 CMP\n与 SUB 类似，目的操作数 - 源操作数，不回送结果。\n1 2 CMP\tAL,\t55H\t; 比较AL与55H的大小 JA\tC2\t; 如果AL\u0026gt;55H，则跳转C2 跳转指令 实现的基础是通过上述逻辑运算和比较指令实现对CPU标志位的修改，跳转指令判断标志位的值，决定是否跳转。\n按标志位的比较结果跳转\n基本上记住前两个就行，第 3、4 个稍微留意一下。\nCMP 指令专用\n重点记一下无符号数的，看起来有 8 条，实际上只用记 4 条。主要记一下 JA，JAE，JB，JBE。\n举几个例子 AL中bit5（从零开始）为“1”时跳转到标号C1 1 2 TEST AL, 00100000b JNZ\tC1 AL中bit0、bit1、bit4任一位为1时跳转到C2 1 2 TEST AL, 00010011b JNZ C2 AL中bit1、bit2、bit3全部为1时，跳转到C3 1 2 3 AND\tAL,\t00001110b CMP\tAL,\t00001110b JZ\tC3 汇编中的不常见指令 看一眼有个印象就好，感觉不需要特意记，特别是移位指令，想稍微记一下的话我也写了怎么记。\n移位指令 用的其实不多，但出现的时候你得学会看他是干嘛的。\n拆解一下，如何看出来移位指令的作用。首先，移位指令都占三个字符位，共计 8 种移位指令。从左往右我们一个个字符位说。\n第一个字符位\nS：Shift，意为移位，最朴素的移位，不循环。 R：Rotate，意为循环，循环移位。 第二个字符\n首字符为 S，不循环朴素的移位，接下来考虑新位的补全方式 H：逻辑移位，新多出的位总是填 0 A：Arithmetic，算数移位，填充依据符号 首字符为R，循环移位，不考虑补全，考虑是否带进位 O：不带进位的循环移位 C：带进位位的循环移位 第三个字符\nR：右移 L：左移 看到移位指令，每个字符逐个分析，哪怕忘了其中某个字符的意义，也可以基本得出其作用。\n乘除 MUL\n8bit / 16bit / 32bit 无符号乘法，被乘数隐含在 AL / AX / EAX（根据乘法的位数是几位，寄存器也要对应位数）。\n注意下积存储的位置。\n1 2 3 MOV\tAL, 5H MOV\tBL,\t10H MUL\tBL\t; AL*BL -\u0026gt; AX 有符号乘法用 IMUL，乘数、被乘数、积都用补码来表示。用的不多。\nDIV\n8bit / 16bit / 32bit 无符号除法，被除数隐含在 AL / AX / EAX。注意，8bit / 16bit 等指的是除数的位数，被除数的位数为除数的位数*2 。\n1 2 3 4 MOV DX, 0 MOV AX, 8003H MOV CX, 100H DIV CX\t; DX:AX / CX -\u0026gt; AX 堆栈 \u0026amp; 高级过程 不一定考，但我个人觉得这一块可以做一个不大的考点。\n高级语言，如 C 语言中，调用函数时我们常常需要传入参数。C 语言中的一个函数，对应汇编语言中的一个过程，通过堆栈，我们可以将传入参数、函数内定义的局部变量都存储在堆栈之中。\n传入参数\n前面讲过两个指针寄存器，BP 与 SP，前者用于随机访问堆栈内的元素，后者用于指向栈顶位置。本例中，使用其对应的 32bit 版本，EBP 与 ESP。\n假设我们程序需要传入两个参数，一个是 5，另一个是 6，调用过程之前，会向栈中先压入第二个参数（6），再压入第一个参数（5），最后，压入程序的返回地址，此时 EBP 指向 返回地址 示意图如下。\n在汇编的过程中接收这两个参数的过程是这样的。\n1 2 3 4 5 6 7 8 9 10 11 AddTwo PROC push ebp\t; 保护现场，EBP原来的内容入栈，ESP指向EBP的内容 mov ebp,esp ; ESP赋予EBP，后续过程执行中，可能涉及到堆栈的操作，影响ESP位置， ; ESP赋值到EBP后可以保证EBP始终指向初始位置，通过EBP可以调用各项参数 mov eax,[ebp + 12] ; 读入第二个参数，位于[EBP+12] add eax,[ebp + 8] ; 读入第一个参数，位于[EBP+8] pop ebp\t; 恢复现场，出栈，此时ESP指向返回地址 ret 8 ; 之前讲过程调用的时候，ret后面都没有接参数，是因为没有用到传入参数。 ; ret 8 指的是废除压入的两个参数（共占8个字节，所以是ret 8）， ; 具体实现是 ESP=ESP+8，此时指向图中EBP+16的位置，结束程序，释放空间 AddTwo ENDP 创建局部变量\n高级语言在函数中创建局部变量，也是存储在堆栈中的。\n1 2 3 4 5 6 7 void function() { char x = \u0026#39;x\u0026#39;; int y = 10; char name[20]; name[0] = \u0026#39;b\u0026#39;; double z = 1.2; } 汇编的过程中，新创建的局部变量，通过逐个入栈进行创建，通过EBP进行相对寻址访问。\n如图所示，最初ESP指向返回地址的位置，EBP入栈，保护现场，同时ESP赋予EBP。接着按顺序创建局部变量，x，y，name，z 依次入栈，ESP最后指向 z ，栈顶位置。如果要访问局部变量，通过右表，对 EBP 进行一定的偏移访问。\n注意的是，为了对其，char 即便只占 1 Byte 长度，仍补全为 4 Byte（32位机）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 MySub PROC push ebp mov ebp,esp sub esp,36\t; 局部变量共占用长度为 36Byte，一次性将栈顶指针移动 mov BYTE PTR [ebp-4],\u0026#39;X\u0026#39; ; 创建 X mov DWORD PTR [ebp-8],10 ; 创建 Y mov BYTE PTR [ebp-28],\u0026#39;B\u0026#39; ; 创建name，初始化name[0] mov DWORD PTR [ebp-32],3ff33333h ; Z(high) mov DWORD PTR [ebp-36],33333333h ; Z(low) …… …… mov esp,ebp ; 栈顶重置为EBP位置，清除局部变量 pop ebp ret MySub ENDP IN \u0026amp; OUT 专门用来访问外设，注意8086独立编址，IO地址只需要16bit即可表示。\n作业 第 3 章作业到这里就都可以做了。\n总线 概述和发展历程之类，这里就不多记录了，记录一些重要的考点。\nAEN 信号 \u0026amp; DMA控制器 搭配 DMA控制器 使用，AEN = 1 时，DMA控制器控制总线，反之 CPU 控制总线。\nDMA控制器通过 PCI 总线支持的多主控设备方式，实现不经过 CPU 实现设备与内存之间的直接数据传送。\n总线驱动与控制 这一块的考点一般都是驱动器选择，双向驱动选通条件（地址分析）。\n驱动器选择 直流负载 驱动门的直流参数有四个，I~IH~, I~IL~, I~OH~, I~OL~，简单而言，直流驱动门选择的逻辑就是\n输出的高电平电流 I~OH~ 需要大于等于负载总的高电平输入电流 SUM( I~IH~) 输出的低电平电流 I~OL~ 需要大于等于负载总的低电平输入电流 SUM( I~IL~) 驱动门的参数，前两行不说也会看，第三行表示驱动同类门的个数。通过上述两点计算，同时满足两点的最大数值。\n交流负载 交流驱动门的依据是 C~P~，满足的条件需要为 C~p~ \u0026gt;= SUM( C~I~ ) + 其他电容。\n一般题目中只考虑 SUM 的部分。\n举个例子 一般考察会结合直流和交流一起考察，举个例子，其实这类题很好做。\n双向驱动（三态门）选通条件 这个是本章重点，其中涉及到地址分析的更是后面几章的基础。三态门，简单而言就是连接在总线与外设之间的一个器件，正常情况下不导通，确保外设与总线之间不产生竞争现象。当 CPU 需要访问外设时，如向外设输送地址、输送数据，此时需要三态门 总线 -\u0026gt; 外设 导通；当 CPU 从外设获取数据时，此时需要三态门 外设 -\u0026gt; 总线导通。依据导通的条件，正确设计连线，这是必考题。\n具体的看 PPT 上 / lsc 笔记上的例子，这是个比较复杂的例子，弄懂这个， 基本后面涉及到三态门选通的题目都没有问题。给个图，题目和分析过程就不放了，PPT 或 笔记雨课堂里都有。\n作业 第四章可以做了。\n存储技术 本章是重点，考察内容包含SRAM的字拓展与位拓展，同时需要结合上一章的地址译码考察，要画电路图，写汇编程序等。\n全地址译码 / 部分地址译码 不算重点，但最好了解。\n首先，要知道本章重点在讲内存如何与 8086/8088 CPU 连接。内存，即 SRAM 芯片，将一块 SRAM 芯片与 CPU 相连，依据地址线连接的条数，有两种方式。举个例子，用一片 SRAM 连接到 8088 CPU，其所占地址空间为 F0000H ~ F1FFFH。\n全地址译码电路 所有地址线都参与地址译码，连线多，但不浪费内存地址空间。\n如图，仅当地址范围为 F0000H ~ F1FFFH 时，会选中当前 SRAM。\n部分地址译码电路 部分高位地址线不连接，连线少，但浪费内存地址空间。\n图上四种地址范围，都会选中该片 SRAM，所以造成了地址空间的浪费。\n多片 SRAM 构成 8088 内存 重点了。8088 的内存结构理解比较简单，换成 8086 要注意双体内存的特点。\n字拓展 字拓展，理解为将存储容量拓展。其实很简单，比如我有两片 2K*8bit 的 SRAM 芯片，我只插一片，可以有 2KB 的内存；如果我觉得还不够，我再插一片，我就拥有了 2*2KB 的内存。这就是字拓展。\n以下图为例，将两块 SRAM 分别占用不同的内存地址空间，就构成了字拓展。\n位拓展 全名是存储位拓展。什么叫存储位？存储位就是内存的最小单元有几位二进制位。如果最小单元为 4bit，那么存储位就为 4bit。位拓展就是拓展存储位，将两块存储位为 4bit 的 SRAM 相连，可以构成一块存储位为 8bit 的整体，这就叫位拓展。\n为什么要位拓展？以 8086 为例，其内存要求的最小存储单元尺寸为 1Byte，也就是 8bit，如果 SRAM 存储位只有 4bit，那 8086 是没办法访问的，因为超过了最小的存储单元尺寸，8086 无法一次只访问 4bit 的数据。因此，需要位拓展以适应与 CPU。\n由于 8086 的双体内存结构，最小的访问单元是字（16bit），因此，将两片 2K*8bit 的 SRAM 以双体内存的形式，构成最小范围党员为 16bit 的 8086 的内存。\n注意，双体内存一定是偶存储体占用低8根数据线。\n汇编读数据 用汇编来读内存里的数据，如读地址为 80002H 开始的 16bit 数据。\n1 2 3 4 MOV\tAX,\t8000H MOV\tDS,\tAX MOV SI,\t2H MOV\tAX,\t[SI] 如果只读 8bit 。\n1 2 3 4 MOV\tAX,\t8000H MOV\tDS,\tAX MOV SI,\t2H MOV\tAL,\t[SI]\t; 改用 8bit 的寄存器即可 注意如果不对齐，CPU 要访问两次内存才能取回数据，但在代码上体现出来都是一样的，只不过地址换为奇数地址。\n如何判断数据是否对齐？16bit的数据，起始地址为偶数，则对齐（仅限于 8086）。\n作业 5.1 的作业可以做了。\nROM 作译码器 非重点，看一下了解即可。\nROM，只读存储器，与RAM相对，本质上也是一个存储器，通过获取输入的地址，返回对应地址的数据。以一道题目来讲一下，基本就可以明白了。\n现在要用4片6264构成一个存储容量为32KB的8位存储器（字扩展），其地址空间为E0000H~E7FFFH。 用一块512 4（即512个存储单元，每个存储单元为4位）的PROM芯片63S241作为ROM译码器。\n红黄绿蓝是四个时间段传入的数据。实际上就是在 ROM 地址空间中的 070H ~ 073H 分别写入 1110，1101，1011，0111。假如我现在要访问 E0002H 的内存地址，输入 ROM 中就是取了其中 070H 部分的内容，ROM 输出了 Q~0~ ~ Q~3~ 为 0111 的信号，低电平选中，只需要将 0 的那条线路连中对应该块地址的 SRAM，即可完成地址译码。\n示意图，重要在理解 ROM 的作用，中间是下拉电阻，保持电压稳定。\nRAM 设计题目 重点，作业也有类似的题目，这里再给一道例题。\n现有容量为 8K 8bit 和 4K 8bit 的SRAM芯片。在8086系统中：\n利用这样的芯片构成地址范围为C2000H~C7FFFH的内存，画出最大模式下包括总线驱动在内的此芯片与系统总线的连接图（译码器件自行选择，尽量选择容量大的芯片） 试编写8086汇编语言程序，从地址C2000H开始，依次写入数据，直到地址C7FFFH。要求数据从0开始，每写入一个字节后数据加1，即写入数据依次为：00H、01H、02H、03H、\u0026hellip;\u0026hellip; 、FEH、FFH、 00H、01H、…… 。然后逐个单元读出比较，若有错，则在DL中写入01H，退出检测；若每个单元均对，则在DL写入00H。 答：\n这类题目，有个大体的分析模板，我在这里用这个模板分析做一下这道题。有些东西用文字还是不太好描述，只能写的尽量详细点，不懂再问。\n1. 确定所要构成的空间大小，以及所需要的芯片数目。\n地址范围为 C2000H ~ C7FFFH，由 C7FFFH - C2000H + 1 = 6000H = 6*2^12^ = 24KByte。\n题目要求首选大容量芯片，因此，首选 8K*8bit 的芯片。由于构成的是 8086 双体内存结果，所选的芯片必须为成两套的芯片，即两组一模一样的芯片，分别构成奇偶内存体。\n因此，奇偶内存体分别选用一块 8K*8bit 与一块 4K*8bit 构成，所有芯片共计选择 4 块， 8K*8bit 与 4K*8bit 各选择两块，容量合计也正好为 24KB。\n由于 SRAM 芯片都为 8bit，8086 而言，奇偶存储体的结构需要以 16bit 作为单元，因此，将两块 8K 与两块 4K 之间分别作奇偶存储体的位拓展，形成 16bit 的存储器。\n2. 地址译码分析。\n依上文分析，我们需要构成 24KB 的内存。将 C2000H ~ C7FFFH 的内存地址变化列出如下。\n每一行的地址范围，涵盖了内存空间为 24KB / 6 = 4KB，位拓展后，我们有 8K * 16bit 与 4K * 16bit 的存储器各一块（这个位拓展已经是把奇偶存储器一块算进去了，如 8K * 16bit，是由一块 8K * 8bit 构成偶存储体，一块 8K * 8bit 构成奇存储体，位拓展而成）。\n因此，划分地址空间上，前 4 行用作 8K * 16bit 的地址空间，后 2 行用作 4K * 16bit 的地址空间。\n再看两个存储器的地址引脚数（位拓展不改变地址引脚数），由 2^13^ = 8K，8K * 16bit 的地址引脚数为 13，同理，4K * 16bit 的地址引脚数为 2^12^。\n如图，在地址范围内，用红圈圈起对应位数的地址位，忽略 A~0~ 作为奇偶存储体选择信号。\n现在进行地址译码中最重要的一部分，**依据地址范围的特点，选择特定的地址信号线进行地址译码，实现访问特定地址时，选通特定内存芯片的效果。**本例中，我们有两块存储体需要选通，其选通的地址空间分别就为前四行和后两行。观察地址特点，A~13~ 与 A~14~ 两位的变化可以决定选中哪一部分的存储器。\nA~14~ A~13~ 效果 0 0 都不选中 0 1 选中 8K * 16bit 1 0 同选中 8K * 16bit 1 1 选中 4K * 16bit 为了译码方便，再选入 A~15~，构成三位，以使用 3-8 译码器构成地址译码电路。（当然，只用两位，通过 2-4 译码器构成也是可以的，但 2-4 用的太少了）\n3. 作出译码电路部分电路图。\n依据地址范围特点，作出译码电路部分的电路图。\n4. 作出内存部分电路图。\n5. 作出驱动器与三态门部分电路图。\n数据线使用双向驱动（三态门），因为存在读入与写出的双端交互。\n余下的仅有单向传输需要的，用单向驱动器。\n6. 整理下，获得整体的电路图。\n不过一般而言，也可以先画驱动，再画其他的，这样信号可以比较好判断用不用加一撇。\n7. 汇编程序\n如果电路图实在不会画，考试也尽量把汇编写出来，电路图画不画没有影响，有题目了汇编就可以写。\n不熟悉的话，推荐使用 8bit 写。\nROM 只读存储器 正式介绍下 ROM，只读存储器。与 RAM 随机存储器最大的区别在于，存在非易失性，掉电不会影响里面的内容，但同时需要写的话不容易写，所以一般用作存储（也就是俗称的硬盘）。不过，某些擦除比较方便的 ROM 和 RAM 一样，也可以连在 8086 的总线上，占用内存的地址空间。\n至于这个东西怎么考？概念的东西就不说了，大体翻翻ppt，知道这个东西的特点、基本原理即可，大题上，这个东西会结合上面的 RAM 设计题考察。体现就在于要你综合设计 ROM 与 RAM。\n但这个其实也不难，原理其实是和 RAM 的设计题一模一样的，你就分开分别设计 ROM 与 RAM，分别分析地址空间，连线画图即可。\n简单举个例子 利用2732（8K 8bit SRAM）和6264（4K 8bit EPROM）构成从 00000H~02FFFH的ROM存储区和从03000H~06FFFH的RAM存储区。画出与8088系统总线的连接图。 （不考虑板内总线驱动）\n选片分析 \u0026amp; 地址译码分析\n连线\n如果将SRAM芯片改成8K 4bit，则在上面基础上加入一个位拓展即可。\nEEPROM 电可擦除只读存储器构成主存 这个要掌握，作业里有。\n一个典型的 EEPROM 芯片的型号是 98C64A。\n引脚与功能 A 是地址线引脚，D 是数据线引脚，与 RAM 一样，没什么好说的。\n!CE 是片选，为 0 时工作。!OE 是允许输出，需要读的时候，置为 0 。!WE 是允许写入，需要写的时候，置为 0 。\n比较特别是最后这个 Ready/!Busy 引脚。\n之前说过，ROM 的写入是不太容易的，因此，如果 CPU 向 ROM 写入了数据，需要等待 ROM 处理一段时间，才能真正完成数据的写入，在处理这段时间内，该引脚就会置为 0，表明目前正忙。\n构成 8088 内存 和之前 RAM 构成内存很像，最大区别就在于多了个 Ready/!Busy 信号的读取。\n这个引脚通过一个外设门来连接到总线中的 D~0~ 上。外设门有独立的接口地址，CPU 读这个外设门，门就会打开，将 Ready/!Busy 信号传到 D~0~，用以判断 ROM 是否完成了写入。\n汇编 把芯片内部所有的单元写入55H。没有用到 Ready/!Busy，取而代之的是每次写入延时 20ms，等待其完成写入，再写入下一个。\n如果要启用 Ready/!Busy，每次写入查询这个引脚状态，一旦不为 Busy，则可以继续写入。\n给外设门设计译码电路。\n通过查询 Ready/!Busy的方式，改进写入逻辑。\n作业 第五章作业都可以做了。\nI/O 技术 这章以及后面一章，主要讲述 CPU 如何与外设通信。包含几种连接在总线与外设间的元器件，它们负责 CPU 与外设间的通信，依据 CPU 的指令，适时地开合。本章重点讲述中断处理。\n需要注意的是，后面涉及到外设、I/O 接口等，地址线无论是 8086，8088，都只需要用 16 根。因为外设是独立编址的，最大为 64KB，刚好 16 根地址线可以满足。\n汇编中的 I/O 指令 前面的没讲，这里补充下。\n向外设读入数据 1 2 MOV\tDX,\t0800H\t; 外设地址，必须存在DX寄存器(?) IN\tAL,\tDX\t; 从DX地址的外设中写入数据到AL 向外设写出数据 1 2 3 MOV\tDX,\t0800H MOV\tAL,\t0FFH OUT\tDX,\tAL\t; 向DX地址的外设写入FFH 基本输入 / 输出方法 CPU 控制 I/O 的方式大体可以分为 3 种。\n无条件传送方式 有一些最简单的外设不需要查询，可以随时给它发命令，随时读它的状态，这种外设可以采用无条件传送的方式。\n输入设备 通过一个三态门，连接外设与总线。当 CPU 需要读取外设输入信息时，在地址线上传入外设的 I/O 地址，经过译码器作用，三态门被选中，导通，外设的数据传送到总线上，CPU 读入数据。\n输出设备 类似地，通过一个锁存器，仅当 CPU 选中外设地址，且需要写外设时。CPU 将数据铺到总线上，由于输出的数据只在 OUT 指令执行瞬间呈现在数据线上，时间非常短，所以输出接口需要有锁存功能，将总线的数据读入到锁存器内，持续提供给外设。\n查询方式 与简单的无条件传送不同，查询方式要求 CPU 在读/写外设前先查询外设状态，若外设准备就绪则可以进行读/写，否则拒绝，CPU 等待。\n查询的方式，通常需要外设有相应的状态接口。我们上面讲的 EEPROM，也提供了一个 Ready/!Busy 接口，其实与外设的查询方式基本是一致的，只不过上面的是 ROM，用的主存地址，外设用的 I/O 地址。因此，具体的例子也不讲了，题目遇到了我们在题目里说。\n多外设的查询\n多个外设使用查询方式，有几种方法。\n这种不好，要是某个坏掉了就一直卡着了。\n这个不错。\n不需要优先级可以这样。\n中断方式 除了上述两种信息交互方式，还有一种方式，即外设需要与 CPU 交换信息时，向 CPU 发送一个中断请求，令 CPU 先放下手头的任务，中断来处理当前的请求任务。\n8086 处理中断的逻辑在前面讲过一些，这里着重讲的是来自 INTR 引脚（可屏蔽中断请求）的中断请求，一般对应了外设的中断请求。\n图中的 8259A，可以从多个可屏蔽中断请求中选取当前优先级最高的中断请求，然后向 CPU 发送 INTR 信号，请求中断。\n具体的中断处理过程，包括CPU响应中断，回复!INTA信号，以及保护现场，查找中断向量表详细过程，在下图中有部分体现，如果对整个过程还不太清楚，继续往下看，后面结合 8259 工作方式有讲解。\n需要注意的几点：\n1413:0105 表示内存地址，左侧表示段寄存器，右侧表示段内偏移。 8086 采用小端存储，小地址对应低字节，大地址对应高字节。 CPU硬件在响应中断时会自动关中断。如果中断服务程序允许中断嵌套，在保护现场之后加开中断指令STI，恢复现场之前再用关中断指令CLI。 可编程中断控制器 8259 对8个中断源实现优先级控制 支持多片级联，一个主片可以有8个从片，可扩展至对64个中断源实现优先级控制。可编程设置不同工作方式。\n可编程就是该芯片内部有一些寄存器，往寄存器里面写入不同的内容就可以具有不同的功能，可以 工作在不同的模式下。\n外部引脚 首先看看这只蟑螂有哪些外部引脚，以实现一个判断中断优先级并选入最高优先级中断的功能。\n注意，这里的芯片引脚图只是个参考，并非所有 8259 芯片的引脚都如图，可能会有命名上的差异，或者高低电平上的差异，但整体而言大同小异。\n中断源输入引脚 IR0 ~ IR7，每块 8259 可以有 8 个中断源输入。 双向数据总线 D0 ~ D7，连接到系统数据总线的低 8 位。 中断请求 INT 与中断应答 !INTA。 读写信号，WR 与 !RD，要对 8259 的内部寄存器进行读写，读写时传数据通过8根数据线。 片选 !CS，也用于多片级联，需要看访问哪一片。 地址 A0，8259 含一根地址线，占用两个接口地址。 其他引脚与级联使用有关。 内部寄存器 为了正确将优先级最高的中断输入给 CPU，8259 需要用到 3 个寄存器。\n中断请求寄存器 IRR：保存从IR0 IR7来的中断请求信号，某位=1表示对应的 IR~i~ 有中断请求。\n中断屏蔽寄存器 IMR：存放中断屏蔽字，某位=1表示对应的 IR~i~ 输入被屏蔽。\n中断服务寄存器 ISR：保存正在服务的中断源，某位=1表示对应的 IR~i~ 中断正在被服务。\n除此之外，涉及到初始化与级联相关使用，和可编程信息的存储器还有 7 个，4个初始化命令字 ICW1 ~ ICW4，还有3个操作命令字 OCW1 ~ OCW3。OCW1 其实就是 IMR，所以8259内部总共有9个寄存器。\n一个例子说明 8259 的工作方式 某一时刻，8259 内部各寄存器状态如下，假设当前设置的优先级判别为数字小的中断请求优先级高于数字大的，即 IR2 \u0026gt; IR5。\n先看 IRR 寄存器，第 2，3，5 位被置 1，说明这 IR2，IR3，IR5 当前有中断请求输入。\n再看 IMR 寄存器，第 2 位置 1，说明屏蔽了 IR2 的中断请求输入。\n继续看 ISR 寄存器，第 4， 6 位置 1，说明 CPU 正在同时处理两个中断请求，且肯定发生了中断嵌套（一个中断处理的过程中继续被中断，处理另一个优先级更高的中断）。\n回看 IRR，发现 IR2，IR3 这两个位置上的中断优先级比正在处理的中断优先级都要高（IR2，IR3 \u0026gt; IR4, IR6）。而 IR2 被屏蔽，那么 8259 就要为 IR3 通过 INT 向 CPU 发送一个中断请求。\nCPU 接收到 INT 请求后，如果 IF 为 1，开中断允许，则 CPU 会保护断点，将 Flags，CS，IP 入栈，将 IF 清 0 关中断。随后，CPU 通过 !INTA 传送出连续两个负脉冲。\n8259 接收到第一个负脉冲就知道CPU正在响应刚才的中断请求，因为CPU马上要执行到IR3对应的中断源的中断服务程序，会将ISR的第3位置1，IRR的第3位清0；同时，它会准备好发出中断请求的中断源的8位中断向量码，等第二个负脉冲来时将其放在低8位数据线上让 CPU 采样得到。\nCPU 在中断服务程序执行完之后通知 8259 可以将 ISR 的相应位清 0。在中断服务程序的最后恢复现场之前，要给 8259 发一个 EOI 中断结束命令。\n要实现 EOI 功能需要 3 条指令，先将 8259 的偶地址（ 8259 只有 一根地址线，地址线给0是偶地址，给1是奇地址）放到DX，要写入的内容放在AL，再用OUT指令把AL 的内容写入到DX所指向的接口。\n1 2 3 MOV\tDX,\t8259偶地址 MOV\tAL,\t20H OUT\tDX,\tAL 写的数是20H，是一般EOI命令。\n允许中断嵌套并且是正常优先级的情况下就会在在中断服务程序的末尾向8259发一个一般EOI命令。8259接收到命令后将ISR中优先级最高的那一位清0，因为有正常优先级概念的情况下，如果允许中断嵌套，最先执行完的中断服务程序肯定是优先级最高的。\n一个例子并不能说完 8259 的工作方式 由于这玩意是可编程的，当然不可能一个例子就说完啦。\n总的来说，8259 的可编程表现在于以下方面可以根据需求设置。\n看完后是不是一脸懵逼？没事，我也一脸懵逼。接着看下面的图，要如何按需求选择工作方式，就一目了然了。\n缓冲模式，双向数据线需要加一个74LS245驱动器，由于后面都没怎么提到，默认为工作到非缓冲方式下。至于中断允许嵌套与屏蔽方式，直接引用下笔记里的表述。\n优先级和级联在下面开个主题单独聊。\n优先级 固定优先级 也就是我们上面举的例子，优先级默认从低到高为 IR7 ~ IR0。\n自动循环优先级 这种方式下，某中断请求被处理后，其优先级别自动降为最低，原来比它低一级的优先级上升为最高级。初始的优先级顺序可由编程改变。\n指定循环优先级 与固定优先级类似，但优先级顺序可以编程指定。\n级联 级联我觉得考难的可能性不大，比较复杂，不过还是要注意下。\n单片 8259 可支持 8 个中断源，采用多片 8259A 级连，可最多支持 64 个中断源。n片 8259A 可支持7n+1 (n \u0026lt;= 9) 个中断源。（除了主片，每片 8259 级联占用一个 IR 口，提供八个 IR 口，因此总共有为 7(n-1) + 8n）。\n主片通过接收到第一个负脉冲后会对ISR和IRR置位。主片替从片向CPU发中断请求，就会通过CAS0~CAS2这3根线送级联地址给两个从片，两个从片在中断应答的第一个负脉冲会检查这3根线的状态与ICW3内容作比较，一致则对ISR和IRR置位，并在第二个负脉冲来时提供中断向量。\n举个例子，从片1有中断请求，总片将其中断请求通过 IR3 输入，并提供至 CPU，CPU 响应，总片将 CAS0 ~ CAS2 置为 011 （IR3），两个从片收到 CPU 的 !INTA 后，检查 CAS，若 CAS0 ~ CAS3 = 自己的 ICW3，说明自己的请求被响应。本例中就是从片1知道自己被响应。\n一般嵌套方式与特殊全嵌套方式的区别主要在于封锁的 IR 口数量不同，如下。\n8259 编程使用 寄存器格式不用记，考到了会给。\n内部存储器的访问如图。\n由于 8259 有一车可以初始化的寄存器，只有奇偶两个地址是不够用的，因此可以看到，数据线的 D4 和 D3 实际上也被用作了地址。\nICW 寄存器 一般而言，初始化 8259，首先要写 ICW1，那么我们先看 ICW1 的结构。\nICW1：初始化字 LTIM 表示 IR0 ~ IR7 的触发方式。\nICW1写入后启动了初始化过程，接下来要写后面的几个 ICW。至于要写几个 ICW，哪些 ICW 会跳过，见如下流程图。\n最少，需要写 ICW1，I W2 两个寄存器才能完成初始化。而至多需要写满 4 个 ICW 寄存器才能完成初始化。\nICW2：中断向量码 ICW3：级联控制字 ICW4：中断结束方式 OCW 寄存器 ICW 寄存器只能在初始化的过程中写入，工作后不可以更改。而 OCW 没有这个限制，随时可以写，任意顺序能写，写与不写都可以。\nOCW1：中断屏蔽字 OCW2：中断结束和优先级循环 OCW3：屏蔽方式和读出控制字 DMA 控制器 这实际上是上面所说的“第四种方式”。\nDMA 控制器 8237 其可以实现内存到内存，内存到接口之间的数据传送，但不能实现接口到接口之间的数据传送，基本的在计组和操作系统都有讲过，要求不高，不详细讲。\n作业 第 6 章作业可以做了。\n常用接口器件 这章和上一章基本算是连起来的，讲的还是 I/O 相关。上一章着重介绍了 CPU 与外设通信方式中的中断方式，介绍了可编程中断控制器件 8259 。\n而有个未解决的问题在于，上一章我们的重点在于 8259 如何向 CPU 发送中断请求以及 CPU 如何处理中断请求，而外设如何与 CPU 进行中断方式的交互，如何与 8259 相连使得 CPU 可以收到中断请求这一部分，还没有进行说明。\n本章主要讲的接口器件，就是在外设与 CPU，外设与 8259 之间的一座桥梁，通过接口器件，外设可以向 8259 传送中断请求，也可以通过接口器件与系统总线实现数据交互。\n三态门 \u0026amp; 锁存器用作接口器件 最简单的接口器件，也就是我们之前一直在用的三态门 / 锁存器。这个在第五章开头也讲过。\n这里稍微说一下，74LS373、74LS244、74LS245、74LS273 这一类器件都是三态门 / 锁存器 / 驱动器，区别无非是是否具有锁存功能、是否可以双向导通之类的，但本质上不必过于深究各个型号之间的差异，只需要知道这一类器件都是用于驱动 / 特定条件下选通数据即可。但注意的是，RAM 设计部分，单向驱动器用的是244，双向驱动器用的是245。\n上述连接方法，CPU 通过直接访问接口外设地址，就可以导通三态门 / 锁存器，读 / 写接口数据。这种方式虽然简单，但也有问题，即 CPU 利用率较低，大部分时间都花在不停地循环查询外设（比如有时候外设未准备好，CPU 访问该地址会遭到拒绝会是接收到无用数据，造成效率的浪费）。如果想要提高CPU的利用率，外设或者说接口能够引入中断功能，外设不忙需要CPU参与时再给CPU发中断请求。\n具有发出中断能力的输入输出接口 抛弃三态门与锁存器，让我们通过带发出中断能力的接口来连接总线与外设。\n单向中断接口 输出接口里有可以暂存数据的缓冲寄存器，也就是图里那个空窗窗，可以判断该寄存器内容是否为空，即数据是否已被外设取走。\n输出接口工作流程：\n输出接口检测到缓存为空，通过 !INTR 信号向 CPU 发送中断请求，通知 CPU 缓存已空，能否写入新的数据。 CPU 经过一段过程，响应中断，进入中断服务程序，中断服务程序把要传输给外设的下一个数据写入到接口内部的缓冲寄存器，写完直接返回。 接口检测到缓冲寄存器写入新数据，将 !OBF 信号置低电平，通知外设拿走数据。 外设采样数据线，拿走数据且处理完后通过 !ACK 信号发一个负脉冲通知接口数据已被取走。接口将 !OBF 信号置高，同时再次向CPU发中断请求重复刚才的过程。 输入接口工作流程类似：\n输入接口检测到缓存为空，通过将 IBF 信号置为高电平，提示外设现在可以写入数据。 外设通过数据线提供数据，数据稳定后通过 !STB 信号发一个负脉冲，接口在负脉冲的上升沿把数据写入到其的暂存器中。 接口写入新数据后把 IBF 信号置高表示输入缓冲区满，通过 !INTR 信号向 CPU 发中断请求。 CPU 响应中断进入到中断服务程序，从接口把数据读走。 接口将IBF信号置低，重复刚才的过程。 需要注意的是，!STB 与 !ACK 都不是状态信号（持续的 0 或 1 表示某一种状态），而是脉冲信号（通过一个脉冲波形表达某种信息）。\n双向中断接口 可以将输入输出接口整合成一个总的接口，就成了双向中断接口。\n输入 / 输出接口内部有2个寄存器，从CPU角度一个只能写不能读一个只能读不能写，可以占用同一个寄存器接口地址。中断信号整合为 1 个，中断产生后，CPU 通过读状态寄存器得知产生中断的原因并做相应处理。\n8255 可编程并行接口 大题目前来看，按车车的说法是十年来都只考了方式0，但建议还是方式1方式2都多了解下。\n需要实现上述接口（三态门、单向中断、双向中断），可以采用器件为 8255 可编程并行接口。\n8255 的三种工作方式 方式0： 输入状态：相当于三态门 输出状态：相当于锁存器 方式1： 输入状态：具有中断功能的输入接口 输出状态：具有中断功能的输出接口 方式2： 双向输入/输出接口 8255 的引脚接口 最主要的三类数据交互引脚：PA0 ~ PA7 对应 A 口，PB0 ~ PB7 对应 B 口，PC0 ~ PC7 对应 C 口。\n其中，C 口可以拆分为高 4 位与低 4 位，之间可以独立使用。\n任何一个口都可以工作在方式0，A口可以工作在方式1和方式2，B口可以工作在方式1。方式0和方式1可以配置成输入也可以配置成输出。若工作在方式1和方式2需要借用 C 口的部分引脚充当信号线。\n举个例子，若配置 8255 的 A 口工作在方式2。 这 8 根线跟外设之间是双向的，此外构成其他的一些握手信号如 !STB，IBF，!ACK，!OBF 和 !INTR，还需要分别借用 C 口的信号线 PC4 ~ PC7 和 PC3。如果B口刚好工作在方式1，还可以借用 C 口的另外 3 根线充当握手信号线。\nA口，B口，C口各有1个8位的缓冲寄存器，此外还有1个控制字，加电启动后通过写控制字可以初始化 8255，配置具体的哪一个口应该工作在哪种方式下。对这些寄存器进行读写和总线间要有地址线 A0~A1，数据线 D0~D7，和读信号 !RD，写信号 !WR，片选信号 !CS。\n另外还多了1个复位信号RESET，直接接到计算机主板的复位电路引脚。计算机刚一加电后复位电路工作产生负脉冲，将8255内部的控制字自动置成事先设置好的状态即A，B，C口均为输入以避免总线竞争。\n8255 的控制字与状态字 8255的地址线有2根，A，B，C三个口的缓冲寄存器和控制字分别占用地址00，01，10和11。\n8255 读控制字与状态字 如图，通过地址的四种组合，分别能读取 8255 的三个控制字与状态字。\n读状态字（前三个）会读取接口内对应的缓存内容，用于 CPU 获取外设的输入数据。\n8255 写控制字与状态字 同样，通过地址的四种组合，分别能写入 8255 的三个控制字与状态字。\n写状态字（前三个）会改变接口内对应的缓存内容，用于 CPU 向外设输出数据。\n接下来重点讲一下状态字，状态字涉及 8255 的功能设定。\n状态字 按状态字首位是 1 还是 0，可以将 8255 设定为两种功能类型。\n首位为0，方式选择 如图，首位为0时，设定 8255 各口的工作方式。方式0就不说了，讲一下方式1和方式2时 C 口的分配。\n方式1 A口工作在方式1时，C口中如下几位会用作控制、状态信号；若B口此时也工作在方式1，则C口如下另外几位会用作B口的控制、状态信号。C口没有用作控制、状态信号的数据线则可以正常用于输入或输出。\n下面四个图，内部的逻辑不用看，只看状态字和对应的接口，了解接口如何分配。\n方式2 只有A口可以工作在方式2，当A口工作在方式2时，需要占用如下几条C口的数据线作为A口的控制线。同时，剩余的C口数据线可以用作输入输出或是B口方式1下的控制线。\n同理，上面两个图不用追究内部逻辑，看懂状态字和对应的引脚输入输出即可，不用记。\n首位为1，C口位操作 D3~D1选择C口哪一位，D0设置这一位是0还是1 。\n8255 的寻址 \u0026amp; 连接到总线 以方式 0 举例，如图连接。\n通过地址译码电路，可以得到 8255 的 A，B，C口寄存器和控制字的地址为380H，381H，382H，383H。\n看地址线 A0，A1，怎么连确定连的是8086还是8088？\n8259的 A0，A1 连系统总线的 A0，A1，则连的是 8088的系统总线；8259 的 A0，A1 连系统总线的 A1，A2，则连的是8086的系统总线，数据线如果连到系统总线低8位必须要给偶地址，地址译码电路加偶地址存储体选择信号A0必须是低电平的条件。\n应用题举例 方式0 - 打印机接口\n电路图与时序 如图，打印机通过 8255 连接到系统总线，8255 A口与C口均工作在方式 0，同时，打印机的工作时序如下图。\n工作时序可能看不懂，这里解释一下。\n打印机，自然是一个需要输出的外设。8255 工作在方式1，输出状态，因此用作锁存器。CPU将数据送到数据线上，此时，8255 接收到数据，存到内部的 A口寄存器中。同时，给 !STROBE 一个负脉冲，表明现在有数据需要打印，且已经锁存到 A口上。外设收到 !STROBE 的信号后，开始从 A口读入数据。此时，外设将 BUSY置1，表明正忙。\nC 口工作方式的选择 除了数据线，外设还要求有锁存信号 !STROBE，要用B口或C口的某一根线提供（负脉冲宽度要求 1us，无法直接通过较快的总线信号提供）。\n对外设来讲，!STROBE 信号是输入，BUSY信号是输出， 而C口较为灵活，高4位和低4位可以分别配置。可以让C口的高4位配置成输出，只能写不能读，再随便选一根线如 PC6 用作 !STROBE；C口的低4位配置成输入，只能读不能写，再随便选一根线如 PC1，刚好既可以判断 BUSY信号的状态，又可以给它送 !STROBE 信号。\n汇编代码实现访问打印机接口 假设 8255 地址：380H~383H。\n初始化程序 0383H 为状态寄存器地址，10000011B表明，A口工作方式0输出状态，C口高四位输出，B口工作在方式0输入状态（其实B口不重要），C口低四位输入。\n00001101B表明，C口中的PC6初始化置1 。\n8255 方式0 以查询方式实现打印机接口 作业 7.1 作业可以做了。\n8253 可编程定时器 芯片功能 定时器有另外一个我们熟悉的名字，即计数器。定时器本质就是个计数器，通过输入频率已知的时钟信号，对信号进行计数，也就可以达到定时的效果。\n片引脚 8253 即可以编程、带自定义选项的定时器，其内部有 3 个计数器，以及若干寄存器。开始计数时，每一个时钟下降沿计数值 - 1 。\n如图，3 个计数器各自有对应的 16 bit 寄存器用于写入计数初值。有 8 条数据线 $D_0$ ~ $D_8$ 写计数初值分开两次写，先写低 8 bit，后写高 8 bit。\n因为有 3 个计数器，要区分读写的是哪个寄存器，需要地址线 $A_0$ 与 $A_1$ 。除开 3 个计数器对应的寄存器，系统总线可见的寄存器还有控制字。控制字内的内容可以决定不同计数器所工作的不同模式。\n$A_0$ $A_1$ 寄存器 可写 / 可读 0 0 计数器 0 R / W 0 1 计数器 1 R / W 1 0 计数器 2 R / W 1 1 控制字 W 剩余的其他信号线，也就是片选CS，读写RD，WR，不多介绍。\n计数器引脚 继续看每个计数器单独所有的引脚。\nCLK：时钟信号输入引脚。 OUT：输出引脚，计数值减到 0 时，用于通知。 GATE：门控信号，用于暂停 / 启用计数。 工作方式 3 个计数器，每一个都可以工作在 6 种不同的模式。为了不吓到你，就先不把六种模式的图都丢出来了。我们拆分开来，一个一个模式看。设计数初值为 n，时钟周期为 T 。\n方式 0：计数结束时产生中断 先看红框部分。\n第一行，为 CLK 输入的时钟信号。第二行，为写信号，低电平时写入计数初值 n = 4，写入结束，跳回高电平。此时，在下一个时钟周期的下降沿时，开始计数（从 4 开始，而不是 4 - 1）。\n当减到 0 时，OUTPUT 置为高电平，提示计数结束。\n再看红框以外，这里除了正常的计数外，映入了 GATE 门控信号。\n还是 WR，正常地低电平写入计数初值 m = 5，写入结束后转到高电平，下一个时钟下降沿开始计数。计数至 4 时，GATE 置低电平，禁止计数，此时停止计数。直到 GATE 置高电平，允许计数，在下一个时钟下降沿，继续计数。\n关于 OUT 引脚初值 一旦写控制字，规定当前计数器工作在方式0下后，OUT引脚马上就变为低电平。\n写入计数初值 后开始定时计数， 计数值减到0后OUT引脚变为高电平。\n其他方式下，只要写控制字规定工作方式后，OUT引脚马上变为高电平。可将其接到8259的一个中断请求输入引脚，定时向CPU发出中断请求。\n方式 1：可重复启动计数 同样，先看红框。\nWR 置低电平，写入初值 n = 4 后，置高电平，与方式 0 不同，此时并没有立刻启动计数。\nGATE 门控信号置高电平，此时正式开始启动计数，计数器将在时钟的下一个下降沿开始计数，直到计数结束。\n再看红框以外的部分。\nGATE 由低置高，启动计数，计数过程中，GATE 置回低电平，此时不影响计数；计数降至 2 时，GATE 重新置高电平，此时，重置计数，无论当前计数值如何，在下一个时钟下降沿，重新从初值开始计数。\n方式 2：频率发生器 方式 2 可以视为一个分频器。\n红框部分，WR 写入计数初值 n = 4，写入完成置回高电平，计数器从下一个下降沿开始计数。\n减至 0 时，OUT 引脚置 0，紧接着，在下一个下降沿，自动重新开始计数，更新计数初值为 n，重复此过程。\n设时钟周期为 T，计数初值为 n，一个计数周期满足 $t = n*T = (n-1)*T + T$，即可以划分为 (n-1) 个计数阶段和 1 个零阶段。\n再看红框以外，同样，GATE 置 0 时，计数器停止计数，且 OUTPUT 置为高，当 GATE 重新置 1 时，计数器重新从初值 n 开始计数。\n因为方式 2 可以任意设定计数初值 n，同时具有不断重复计数的功能，因此，我们可以任意设定 n，加入周期为 T 、频率为 f 的 CLK 信号，从 OUT 接口，可以得到一个周期为 t = nT，频率为 f/n 的新信号，故所以方式2也叫做分频器。\n方式 3：方波发生器 输入计数初值 n，存在两种情况。\nn 为偶数，此时 OUT 引脚输出对称的方波，每个完整方波（上 + 下）的周期为 n*T。单个方波（上 OR 下）的周期为 n*T / 2。 n 为计数，此时 OUT 引脚输出上半方波更宽的非对称方波，整个方波的周期仍然为 n*T，上方波的周期为 (n / 2 + 1)*T，除法向下取整；下方波周期为 n*T /2。 GATE 的作用与 方式 2 相同，置为低电平时，禁止计数，OUT 置高，置为高电平时，重新计数。\n方式 4 比较简单，看图就可以。\n类似于方式 0，写入初值后开始计数，OUT 初始化为 1，而非 0 。（方式 0 中 OUT 技术过程中为 0，计数结束为 1）。计数结束后 OUT 置 0 一个周期，再置 1 。\nGATE 为低电平时停止计数，但重置为高电平时，不会重新计数，会接着之前的结果继续计数。\n方式 5 同样比较简单。\n写入初值后，当 GATE 由 0 置 1 时，启动计数。计数结束后，与方式 4 相同，OUT 输出一个周期的低电平。技术过程中，GATE 由低置高时，会重置计数为初值，重新开始计数。\n控制字 计数器的计数过程 前面我们提到，计数器有一个计数寄存器，用于存储计数结果，我们可以写这个寄存器，来改变计数初值，或者读这个寄存器，来获取当前计数值。\n实际上，这是抽象出来的一个对外的 API，目的是便于使用。芯片内真正实现计数过程使用了 3 个寄存器。\n计数值寄存器：写计数初值时，实际上把初值写到了这个寄存器里，这个值除非重新写入，否则是不会改变的。 减一寄存器：这计数过程中真正在变的寄存器，计数开始时，第一个时钟下降沿会把初值从计数值寄存器传送到减一寄存器。注意，取初值到减一寄存器这一步并不会判断是否为 0，在下一个时钟周期下降沿，才会对减一寄存器的值减 1，再判断是否为 0 。因此，如果初值写入的是 0000H，在实际计数的过程中，对应的是计数最大值 FFFFH + 1 。 计数锁存器：每次减一寄存器改变，其内容都会同步到技术锁存器。正常工作时这两个寄存器的内容总是一样的。**计数值寄存器和计数锁存器占用同一个地址，写这个地址将计数初值写入计数值寄存器，读这个地址读当前计数锁存器的内容。**减1计数器则不能读也不能写。读计数锁存器之前，要给计数器发锁存命令 ，一旦发锁存命令后减1计数器和计数锁存器切断联系，计数锁存器内容不再变化。 从系统总线的角度来讲，每个计数器好像只有1个相应的16位寄存器，但其实有3个。\n8253的地址3对应控制字，看起来8253内部好像也只有一个控制字，但实际上内部对应每一个计数器都有其专有的控制字。故每一个计数器内部都有4个寄存器：计数值寄存器，减1计数器，计数锁存器和控制字寄存器。\n控制字格式 二进制计数与 BCD 计数的范围如下。\n8253 寻址与连接 8253 的初始化与使用 编程初始化顺序 只需要一个计数器时： 同时需要用多个计数器时：\n示例程序。\n喜闻乐见的串联 单个计数器的限制 假设仅有时钟信号 $f_{CLK} = 2MHz, T_{CLK} = 0.5us$\n此时，单个计数器的最长定时时间 = 最大计数值 $n_{max}$ * 时钟周期 $T_{CLK}$。\n即 $65536 * 0.5us = 32.77ms$\n如果我需要定时时间更长，即输出信号的周期更长，需要将多个计数器串联。\n计数器串联使用 分析下这个图。\n输入 CLK 的周期为 T，设 Timer0 输出的信号周期为 T0，Timer1 输出的信号周期为 T1 。\n$T_0 = n_0*T$\n$T_1 = n_1*T_0$\n即 $T_1 = n_0 * n_1 * T$\n突破了单个计数器的 $n$ 的限制。\n我们分析下为什么需要用方式 2 或方式 3。\n方式 0 无法做到持续计数，一次计数结束后就结束，方式 1 可以重复技术，但需要 GATE 的信号用于重置，方式 4 ，方式 5 与前两者类似，这四种方式都无法稳定持续地计数。\n只有方式 2 （一个周期内 $(n-1)T$ 的高电平 + $T$ 的低电平）和方式 3 （周期为 $nT$ 的方波）才能做到持续稳定又自律地计数并产生输出信号。\n具体选用方式 2 还是 方式 3？\n方式 2：输出信号为周期性的负脉冲，且对负脉冲宽度无要求。 方式 3：输出信号为方波。 如果要求输出指定宽度的周期性负脉冲，如何设计？\n解法 1：\n假设要求的负脉冲宽度（持续时间）为 $W$。\n先看 Timer1，假设 Timer1 采用方式 2 输出，可以知道负脉冲宽度为\n$T_{negative} = T_0 = W$\n设立合适的 $n_0$，满足 $T_0 = n_0*T = W$，即 $n_0 = W/T$。\n此时，就可以在 $T_1$ 获取宽度为 $W$ 的稳定负脉冲。\n至于 $n_1$，则具体需要看为 $T_1$ 设置多长的周期，满足 $T_1 = n_1*W$。\n优点：$T_1$ 为 32bit 计数器的定时结果，即 $T_1 = n_0 * n_ 1 * T$。 限制：$T_1$ 必须为 $W$ 的整数倍。 解法 2：\n同样，先看输出，即 Timer1，Timer1 采用方式 1 输出，则负脉冲宽度为计数时长（在计数时 OUT 就为负脉冲）。观察到 Timer1 的 CLK 输入即为 $T$。\n由于负脉冲宽度即为计数时长，则有\n计数时长 $t = T*n_1 = W$，\n$n_1 = W / T$。即可满足输出指定宽度的负脉冲的要求。\n方式 1 的问题在于需要通过 $GATE$ 完成重复启动，因此，接着看 Timer0 如何产生信号 $T_0$ 来作为 Timer1 的 $GATE$ 输入，使其持续重复启动计数。\n看 Timer0，输出 $T_0 = n_0*T$，无论是方式 2 还是方式 3，上升沿的周期都为 $T_0$。（$GATE$ 在方式 1 时上升沿起效。）。\n只需要满足 $T_0 \u0026gt; W$，那么每隔 $T_0$ 时间，Timer1 都会收到一个 $GATE$ 信号，重新开始计数。因此，$T_1 = T_0 = T*n_0$。$n_0$ 根据需要的 $T_1$ 长度进行设置即可。\n优点：$T_1 可以不是 W 的整数倍。$ 缺点：$T_1$ 是 16 bit 计数器的结果，即 $T_1 = T * n_0$，需要更长的 $T_1$ 时还需要串联更多计数器。 记得做题。\n基于总线的 I/O 接口设计 略过。\n","date":"2022-02-28T19:32:52Z","image":"https://TuJin07.github.io/p/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/cover_hud909cb1be98356b124c5a237e088aad3_1604452_120x120_fill_q75_box_smart1.jpg","permalink":"https://TuJin07.github.io/p/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/","title":"微机原理与接口技术课程总结"},{"content":"基于 Nginx 的负载均衡策略 题目要求 重现课上演示的基于 Nginx 的负载均衡实验（部分工具可根据实际情况进行调整），验证 Nginx 支持的不同负载均衡策略。\n结果写成一篇实验报告，假定读者为技术小白。\n作业背景 正向代理 正向代理最大的特点是，客户端非常明确要访问的目的地址，服务器代理客户端，替客户端发出请求。\n反向代理 随着请求量的爆发式增长，单服务器已经难以负荷，引入了服务器集群。\n此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理，反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。\n换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证。\n负载均衡策略 在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率，这就是负载均衡策略。\n负载均衡策略通常有如下几种。\n随机：随机为后台服务器分配请求。 轮询：按顺序，轮流为后台服务器分配请求。 固定权重值：为不同的后台服务器设定不同权重，以权重为后台服务器分配请求。 IP 哈希：通过对来访 IP 地址进行哈希映射，作为选择后台服务器的依据。 最少 TCP 连接数：依据与后台服务器建立的 TCP 连接数数量，优先为连接数量小的后台服务器分配请求。 最小响应时间：后端服务器的响应时间来分配请求，响应时间短的优先分配。 基于各服务器负载的动态均衡算法：实时基于各后台服务器的 CPU 占用率、内存占用率等信息，动态计算权重，为负载较轻的服务器优先分配请求。由于算法复杂，占用开销大，实际情况一般不采用。 本次作业中，主要基于 Nginx 测试并验证轮询、固定权重值、IP 哈希、最少 TCP 连接数 4 中负载均衡策略。\nLinux 下相关的软件安装 系统环境 本次作业在搭载 CentOS 8.2 操作系统的云服务器上完成，相关软件安装及配置均在对应的 Linux 环境下完成。云服务器 IP 地址为 8.130.15.218 。\n本次作业中需要用到的软件：\nXshell，用于连接远程服务器的工具软件，如在本地进行实验则无需。 Nginx，Web 服务器软件，本次作业中基于该软件实现反向代理与负载均衡。 Node.js，一个开源且跨平台的 JavaScript 运行时环境。封装了 Chrome V8 引擎，提供多种可调用的 API。Node.js 提供了 JavaScript 能在服务器运行的运行时环境。 CURL，使用各种类型的请求向服务器与服务器之间传输数据。 安装 Node.js 下载源代码 前往 Node.js 官网，选择合适的 Linux 版本编译包。获取下载链接，通过 wget 命令在 Linux 中下载。\n1 wget -c https://npmmirror.com/mirrors/node/v16.13.2/node-v16.13.2-linux-x64.tar.xz 输入命令，回车，稍等片刻即可完成下载。\n解压编译包 将下载后的 node-v16.13.2-linux-x64.tar.xz 解压到当前目录。\n1 tar -xvf node-v16.13.2-linux-x64.tar.xz 为方便后续操作，重命名为 nodejs。\n1 mv node-v16.13.2-linux-x64 nodejs 移动文件夹至 /usr/local/bin/ 目录下，该目录通常存放用户的可执行文件。\n1 mv /root/nodejs/ /usr/local/bin/ 配置软链接 使 nodejs 可以全局使用，配置软链接。\n1 2 ln -s /usr/local/bin/nodejs/bin/node /usr/bin/ ln -s /usr/local/bin/nodejs/bin/npm /usr/bin/ 检查安装结果 使用以下命令，访问 node 与 npm，若返回版本信息则说明安装完成。\n1 2 node -v npm -v 返回信息如下。\n至此，Node.js 的安装完成。\n安装 Nginx Linux 环境下，通过 yum 命令可以简单快捷完成对 Nginx 的安装。\n安装前的准备 检查本机是否已经安装了 Nginx。输入以下命令，并回车。\n1 which nginx 这条指令可以找到服务器上安装的 Nginx 位置，如果没有安装过，则会提示找不到相关路径。如下图红框部分所示，我的服务器显示未找到 Ngnix 的相关路径。\n安装 Nginx 输入以下命令并回车，等待下载最新版本的 Nginx，并在安装前提示是否确定时输入 y。\n1 yum install nginx 安装完成后，会提示 complete!，此时，默认下的安装目录为 /user/sbin/nginx。再次通过 which nginx 指令，可以查询到安装位置，如图。\n通过以下命令检车 Nginx 版本。\n1 nginx -v 启动 Nginx Nginx 安装完成后并不会自启动，通过以下命令启动 Nginx。\n1 systemctl start nginx 同时，类似地，重启与停止 Nginx 的命令如下。\n重启 Nginx。\n1 systemctl restart nginx 停止 Nginx。\n1 systemctl stop nginx 如果服务器中已经安装启用了 Apache 等类似 Web 服务器软件，先将其停用，避免互相影响。\n启动 Nginx，启动成功则不会返回任何信息，没有响应就是最好的响应。在浏览器中输入你的服务器 IP 地址，出现以下欢迎页面，则表明 Nginx 已启动成功。\n至此，Nginx 的安装和启用完成。\n安装 CURL 安装 CURL 不一定要在 Linux，也就是我们本次作业中使用的服务器上安装，在其它 PC 机中安装 CURL，再通过 CURL 访问服务器一样可以达到验证的效果。\n在 CentOS 上安装，以 root 用户身份输入以下命令。\n1 yum install curl 检验 要确认 CURL 是否安装，输入以下命令。\n1 rpm -qa | grep curl Nginx 支持的负载均衡策略实验 测试前准备 创建监听不同端口的服务器 创建 JavaScript 源文件 移动至 /home/code/ 目录下，新建 4 个 JavaScript 文件，以其中一个文件 webserver1.js 为例。\n1 2 3 4 5 6 7 var http = require(\u0026#39;http\u0026#39;); var server = http.createServer(function(req, res){ res.write(\u0026#34;Hello world from Server One.\\n\u0026#34;); res.end(); }); server.listen(2321); console.log(\u0026#34;running at http://127.0.0.1:2321\u0026#34;); 写入如上代码，其中，server.listen(2321) 表明当前正在坚挺的端口为 2321 端口，res.write(\u0026quot;Hello world from Server One.\u0026quot;) 对应着在访问本机地址的 2321 端口后，会在页面上显示相应的信息。\n类似地，创建的 4 个 js 文件分别模拟了监听本机 2321 ~ 2324 四个端口的服务器。通过 Nginx 的负载均衡分发，四个端口服务器均有可能被访问，届时具体访问到了哪个服务器，从页面返回的信息即可了解。\n运行 JavaScript 源文件 通过 Node.js 运行上述文件，命令如下。\n1 node webserver1.js 运行后会打印 \u0026ldquo;running at http://127.0.0.1:2321\u0026rdquo;，如图。\n此时，通过浏览器访问对应端口，即可访问对应的服务器。（我的云服务器 IP 地址为 8.130.15.218）\n依次启动其余服务器。\n配置 Nginx /etc 目录时 Linux 下专用于存放配置文件的目录。\n通过以下命令，进入到 Nginx 的配置文件目录。\n1 cd /etc/nginx 通过 ls 命令，将该目录下的文件列出。其中的 nginx.conf 就是我们的目标配置文件。\n通过以下命令，用 vim 打开 nginx.conf。\n1 vim nginx.conf 修改其中内容，添加修改如下部分代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 upstream myservers { server 127.0.0.1:2321; server 127.0.0.1:2322; server 127.0.0.1:2323; server 127.0.0.1:2324; } server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { proxy_pass http://myservers; proxy_set_header Host $host; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } upstream 是用于定义服务器组的模块，同时也可以配置负载均衡功能。location/ 则根据 URL 来决定怎么处理用户请求，如转发请求给其他服务器处理，或者查找本地文件进行处理。\n上述配置文件中，将上文中我们配置的 4 个服务器添加到了名为 myservers 的 upstream 模块中，且在 location/ 中定义了将访问进行转发至 myservers。\n此时，在浏览器中访问 8.130.15.218:80，即云服务器主机的 80 端口，成功跳转至后端服务器组。\n尝试并验证不同的负载均衡策略 轮询 如上文进行 Nginx 的配置，采用的就是轮询的负载均衡策略。通过如下命令，重复使用 CURL 对本机 IP 地址的 80 端口进行 20 次访问。\n1 for i in {1..20}; do curl 127.0.0.1:80; done 得到结果如图。\n如图，20 次访问中，4 个后台服务器是按顺序被轮询访问的。\n固定权重值 可以在 Nginx 配置页面为每台服务器指定权重值。如下所示，为服务器 1，2 分配权值 40，服务器 3，4 分配权值 10 。\n1 2 3 4 5 6 upstream myservers { server 127.0.0.1:2321 weight=40; server 127.0.0.1:2322 weight=40; server 127.0.0.1:2323 weight=10; server 127.0.0.1:2324 weight=10; } 保存，重启 Nginx，使用 CURL 访问，得到结果如下。\n从 20 次访问结果可以卡出，后台服务器被访问的次数基本符合权值分配。\nIP 哈希 如下所示，可以对每个请求按访问 IP 的 Hash 结果分配。\n1 2 3 4 5 6 7 upstream myservers { ip_hash; server 127.0.0.1:2321; server 127.0.0.1:2322; server 127.0.0.1:2323; server 127.0.0.1:2324; } 通过 CURL 进行 20 次访问，得到结果如下。\n可见，每次登录后都访问服务器 1，原因在于我们采用的是同一个 IP 地址对该端口进行多次访问，每次进行哈希运算后分配的到的后端服务器都相同。\n最小连接数 如下图所示，配置后 Nginx 会根据当前后台服务器的连接数来分配访问请求，连接数较小的会优先被分配。\n1 2 3 4 5 6 7 upstream myservers { least_conn; server 127.0.0.1:2321; server 127.0.0.1:2322; server 127.0.0.1:2323; server 127.0.0.1:2324; } 20 次访问结果如下。\n与轮询结果相同，推测是通过 CURL 访问仅建立连接而不释放连接或即时释放连接，导致没有体现出按最小连接数分配的特点。\n","date":"2022-02-04T18:11:52Z","image":"https://TuJin07.github.io/p/%E5%9F%BA%E4%BA%8E-nginx-%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/cover_hubbcff01d8523d34c7e0c058aaa3c8f24_1400464_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/%E5%9F%BA%E4%BA%8E-nginx-%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/","title":"基于 Nginx 实现的负载均衡策略"},{"content":"地图路由（Map Routing） 问题描述 实现经典的 Dijkstra 最短路径算法，并对其进行优化。 这种算法广泛应用于地理信息系统（GIS），包括 MapQuest 和基于 GPS 的汽车导航系统。\n地图 本次实验对象是图 maps 或 graphs，其中顶点为平面上的点，这些点由权值为欧氏距离的边相连成图。 可将顶点视为城市，将边视为相连的道路。 为了在文件中表示地图，我们列出了顶点数和边数，然后列出顶点（索引后跟其 x 和 y 坐标），然后列出边（顶点对），最后列出源点和汇点。 例如，如下左图信息表示右图：\nDijkstra算法 Dijkstra 算法是最短路径问题的经典解决方案。 它在教科书第21章中有描述。 基本思路不难理解。 对于图中的每个顶点，我们维护从源点到该顶点的最短已知的路径长度，并且将这些长度保持在优先队列（priority queue, PQ）中。 初始时，我们把所有的顶点放在这个队列中，并设置高优先级，然后将源点的优先级设为0.0。 算法通过从PQ中取出最低优先级的顶点，然后检查可从该顶点经由一条边可达的所有顶点，以查看这条边是否提供了从源点到那个顶点较之之前已知的最短路径的更短路径。 如果是这样，它会降低优先级来反映这种新的信息。\n这里给出了Dijkstra算法计算从0到5的最短路径0-1-2-5的详细过程。\n1 2 3 4 5 6 7 8 9 10 11 process 0 (0.0) lower 3 to 3841.9 lower 1 to 1897.4 process 1 (1897.4) lower 4 to 3776.2 lower 2 to 2537.7 process 2 (2537.7) lower 5 to 6274.0 process 4 (3776.2) process 3 (3841.9) process 5 (6274.0) 该方法计算最短路径的长度。 为了记录路径，我们还保持每个顶点的源点到该顶点最短路径上的前驱。 文件 Euclidean Graph.java，Point.java，IndexPQ.java，IntIterator.java 和 Dijkstra.java 提供了针对 map 的 Dijkstra算法 的基本框架实现，你应该以此作为起点。\n客户端程序 ShortestPath.java 求解一个单源点最短路径问题，并使用图形绘制了结果。 客户端程序 Paths.java 求解了许多最短路径问题，并将最短路径打印到标准输出。 客户端程序 Distances.java 求解了许多最短路径问题，仅将距离打印到标准输出。\n实验目标 优化 Dijkstra算法，使其可以处理给定图的数千条最短路径查询。 一旦你读取图（并可选地预处理），你的程序应该在亚线性时间内解决最短路径问题。 一种方法是预先计算出所有顶点对的最短路径；然而，你无法承受存储所有这些信息所需的二次空间。 你的目标是减少每次最短路径计算所涉及的工作量，而不会占用过多的空间。 建议你选择下面的一些潜在想法来实现， 或者你可以开发和实现自己的想法。\n想法 1 Dijkstra算法的朴素实现检查图中的所有 V 个顶点。 减少检查的顶点数量的一种策略是一旦发现目的地的最短路径就停止搜索。 通过这种方法，可以使每个最短路径查询的运行时间与 E\u0026rsquo; log V\u0026rsquo; 成比例，其中 E\u0026rsquo; 和 V\u0026rsquo; 是 Dijkstra算法检查的边和顶点数。 然而，这需要一些小心，因为只是重新初始化所有距离为 ∞ 就需要与 V 成正比的时间。由于你在不断执行查询，因而只需重新初始化在先前查询中改变的那些值来大大加速查询。\n想法 2 你可以利用问题的欧式几何来进一步减少搜索时间，这在算法书的第21.5节描述过。对于一般图，Dijkstra通过将 d[w] 更新为 d[v] + 从 v 到 w 的距离来松弛边 v - w。 对于地图，则将 d[w] 更新为 d[v] + 从 v 到 w 的距离 + 从 w 到 d 的欧式距离 - 从 v 到 d 的欧式距离。 这种方法称之为 A* 算法。这种启发式方法会有性能上的影响，但不会影响正确性。\n想法 3 使用更快的优先队列。 在提供的优先队列中有一些优化空间。 你也可以考虑使用 Sedgewick 程序20.10中的多路堆。\n测试 美国大陆文件 usa.txt 包含87,575个交叉口和121,961条道路。 图形非常稀疏 - 平均的度为2.8。 你的主要目标应该是快速回答这个网络上的顶点对的最短路径查询。 你的算法可能会有不同执行时间，这取决于两个顶点是否在附近或相距较远。 我们提供测试这两种情况的输入文件。 你可以假设所有的x和y坐标都是0到10,000之间的整数。\n注：这个问题的实验由Bob Sedgewick和Kevin Wayne设计开发（Copyright © 2004）。更多信息可参考http://algs4.cs.princeton.edu/。\n问题分析 本实验要求实现经典的 Dijkstra 算法，并对算法进行迭代改进，实现性能上的提升以应对大规模的输入数据。\n在实现朴素的 Dijkstra 算法基础上，不断实现效率上的改进，参考提供的思路，针对本次测试环境，可以制定出以下几种迭代优化方案。\n优化 1\t提前结束搜索 Dijkstra算法的朴素实现每次都会检查图中的所有顶点。我们可以通过减少检查的顶点数量来优化查询效率。具体体现会一但搜索到终点，得到最短路径即可结束搜索。\n优化 2\t降低初始化开销 通过 优化 1 的优化，在理论上我们可以使每次查询最短路径的运行时间正比于 E log V，然而问题在于，每次执行查询算法，仍要进行时间开销为 V 的初始化工作，在这一点上，基于 优化 1 的算法还有进一步优化空间。\n具体的想法是，通过使用队列 Queue（本次实验中具体的实现为 LinkedList）存储那些在上一轮查询中被修改了的点，在本轮查询的初始化过程中，仅对这些被修改过的点进行初始化。此举在 优化 1 的基础上能进一步降低算法运行时间开销。\n优化 3\t对搜索过程采用 A* 算法优化 A* 算法，即启发式算法。在搜寻最短路的效率上，由于考虑了搜索结点到终点的花费，效率上更优于 Dijkstra算法的默认实现。\nA* 通过如下函数来计算每个节点的优先级。\n定义 f(n) 表示节点 n 的综合优先级。选择下一个要遍历的节点时，总会选取综合优先级最高的节点。 定义 g(n) 是节点 n 距离起点的距离。 定义 h(n) 是节点 n距离终点的预计花费，这也就是A*算法的启发函数。 A* 算法的完整运算过程与基本的 Dijkstra算法类似，区别在于在运算过程中，每次从优先队列中选取 f(n) 值最小，即优先级最高的节点作为下一个待遍历的节点。\n启发函数会影响 A* 算法的行为。用 n 表上当前遍历节点，d 表示终点，cost(a, b) 表示由点 a 到达 b 的代价。\nh(N) = 0，直接由 g(n) 决定节点的优先级，此时算法就退化成朴素的 Dijkstra算法。 h(n) \u0026lt;= cost(n, d)，则 A* 算法保证一定能够找到最短路径。h(n) 的值越小，算法将遍历越多的节点，也就导致算法越慢。 h(n) = cost(n, d)，则A*算法将找到最佳路径，并且速度很快。并非所有场景下都能做到这一点。 h(n) \u0026gt; cost(n, d)，则A*算法不能保证找到最短路径，不过此时会很快。 由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是 A* 算法比较灵活的地方。\n对于本次实验的地图模型，我们采用欧几里得距离（Euclidean distance）来构造启发函数。在算法层面的具体实现表现为将 d[w] 更新为 d[v] + 从 v 到 w 的距离 + 从 w 到 d 的欧式距离 - 从 v 到 d 的欧式距离。这种启发式方法会有性能上的影响，但不会影响正确性。\n优化 4\t采用多路堆实现优先队列 尝试采用更快的优先队列以观察其对运行效率上的提升是否有益。用多路堆（四叉堆）替换原始实现中的二叉堆，检验是否带来效率上的提升。\n测试数据集选用 使用提供的地图数据以及测试数据集进行测试，地图数据采用美国大陆文件 usa.txt。选用 usa-100long 与 usa-100short 两种具有不同特点的测试数据集对算法进行性能测试。\n实现细节 Dijkstra 算法的基本实现 未做任何优化的朴素 Dijkstra算法的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 private void dijkstra(int s, int d) { int V = G.V(); // 初始化； // dist[v] 记录点 v 至源点的距离； // pred[v] 记录点 v 最短路的上一个节点。 dist = new double[V]; pred = new int[V]; for (int v = 0; v \u0026lt; V; v++) dist[v] = INFINITY; for (int v = 0; v \u0026lt; V; v++) pred[v] = -1; // 优先队列的创建并初始化 IndexPQ pq = new IndexPQ(V); for (int v = 0; v \u0026lt; V; v++) pq.insert(v, dist[v]); // 设立源点，源点至源点的距离为 0，源点前一个节点为其本身 dist[s] = 0.0; pred[s] = s; pq.change(s, dist[s]); // 修改优先队列里的源点 // 启动 Dijkstra 算法 while (!pq.isEmpty()) { int v = pq.delMin(); // 当 v 点不可达时退出循环 if (pred[v] == -1) break; // 遍历所有 v 点的邻居 IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 如果得到新的距离要比原来更近，则更新长度和路径 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) { dist[w] = dist[v] + G.distance(v, w); pq.change(w, dist[w]); pred[w] = v; } } } } 优化 1\t提前结束搜索 一旦找到终点，立刻结束搜索。体现在 Dijkstra算法的 while 循环中加入了如下语句。\n1 if (v == d) break; 具体的代码实现如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 改进 1：一旦找到目标点，立刻结束搜索 */ // 启动 Dijkstra 算法 while (!pq.isEmpty()) { int v = pq.delMin(); if (pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 如果得到新的距离要比原来更近，则更新长度和路径 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) { dist[w] = dist[v] + G.distance(v, w); pq.change(w, dist[w]); pred[w] = v; } } // 如果以及找到终点，则直接退出搜索，返回结果 if (v == d) break; } 优化 2\t降低初始化开销 在优化1的基础上，通过使用队列 Queue（本次实验中具体的实现为 LinkedList）存储那些在上一轮查询中被修改了的点，在本轮查询的初始化过程中，仅对这些被修改过的点进行初始化。\n1 2 /* 用于记录哪些节点被修改过的队列 */ private LinkedList\u0026lt;Integer\u0026gt; changed = new LinkedList\u0026lt;Integer\u0026gt;(); 同时，为了降低复杂度，对于优先队列 priority queue，每轮查询初始化的过程中不再将所有点的信息入列，取而代之的是只对源点入列，在算法遍历过程中动态更新队列里的节点。\n1 2 3 4 5 6 7 // 对队列内的点以及 priority queue 进行初始化 while (!changed.isEmpty()) { int v = changed.poll(); dist[v] = INFINITY; pred[v] = -1; } pq = new IndexPQ(V); 整体的代码实现如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 改进 2：在改进 1 的基础上将初始化时间优化为压线性 */ private void dijkstra(int s, int d) { int V = G.V(); // 对队列内的点进行初始化 while (!changed.isEmpty()) { int v = changed.poll(); dist[v] = INFINITY; pred[v] = -1; } pq = new IndexPQ(V); dist[s] = 0.0; pred[s] = s; changed.add(s); pq.insert(s, dist[s]); while (! pq.isEmpty()) { int v = pq.delMin(); if (v == d || pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 如果得到新的距离要比原来更近，则更新长度和路径 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) { // 若该点重来没有被遍历过，将其加入优先队列pq，否则修改其在优先队列内的数值 if (dist[w] != INFINITY) { dist[w] = dist[v] + G.distance(v, w); pq.change(w, dist[w]); } else { dist[w] = dist[v] + G.distance(v, w); pq.insert(w, dist[w]); // 将其加入队列，标记该点已被修改 changed.add(w); } pred[w] = v; } } } } 优化 3\t对搜索过程采用 A* 算法优化 采用欧几里得距离（Euclidean distance）来构造启发函数。在算法层面的具体实现表现为将 d[w] 更新为 d[v] + 从 v 到 w 的距离 + 从 w 到 d 的欧式距离 - 从 v 到 d 的欧式距离。在算法上的修改具体体现在如下。\n原来对节点 v 的邻居节点 w 遍历时，更新条件为：\n1 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) {...} 修改更新条件，令其变更变为：\n1 if (dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d) \u0026lt; dist[w] - EPSILON) {...} 同时需要修改的还有 dist[w] 所更新的值。\n具体的代码实现如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 改进 3：在改进 2 的基础上，更改为 A* 算法，即启发性搜索 */ while (! pq.isEmpty()) { int v = pq.delMin(); if (v == d || pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 将d[w]更新为d[v] + 从v到w的距离 + 从w到d的欧式距离 - 从v到d的欧式距离 if (dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d) \u0026lt; dist[w] - EPSILON) { if (dist[w] != INFINITY) { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.change(w, dist[w]); } else { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.insert(w, dist[w]); changed.add(w); } pred[w] = v; } } } 优化 4\t采用多路堆实现优先队列 继续优化，在实现了优化3的基础上，考虑对优先队列这个数据结构本身进行挑战。原始的实现中采用的是二叉堆实现的优先队列。尝试采用四叉堆对优先队列进行重构实现，检验其对性能的提升是否有益。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 改进 4：在改进 3 的基础上，优先队列采用多路堆实现 */ private void dijkstra(int s, int d) { int V = G.V(); while (!changed.isEmpty()) { int v = changed.poll(); dist[v] = INFINITY; pred[v] = -1; } // 四叉堆定义，WAYS = 4 IndexMultiwayMinPQ\u0026lt;Double\u0026gt; pq = new IndexMultiwayMinPQ\u0026lt;Double\u0026gt;(V, WAYS); dist[s] = 0.0; pred[s] = s; changed.add(s); pq.insert(s, dist[s]); while (! pq.isEmpty()) { int v = pq.delMin(); if (v == d || pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); if (dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d) \u0026lt; dist[w] - EPSILON) { if (dist[w] != INFINITY) { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.changeKey(w, dist[w]); } else { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.insert(w, dist[w]); changed.add(w); } pred[w] = v; } } } } 实验结果 测试环境 搭载 Windows 11 操作系统的计算机。\nCPU: AMD Ryzen 5 5600U with 2.30Ghz RAM: 16.0 GB 测试数据 我们对原始算法，以及累计 4 个迭代版本的优化算法进行测试，每种算法分别以 usa-long100.txt 和 usa-short100.txt 为测试数据集，进行 10 轮测试，取平均值，汇总成如下的表格。篇幅所限，在此仅展示统计平均结果，详细的每轮测试耗时见附录。\n算法 usa_long 测试平均耗时 (ms) usa_short 测试平均耗时 (ms) 原始算法 2213.4 2197.7 优化版本 1 1089 165.2 优化版本 2 813.8 99.6 优化版本 3 199.3 42.1 优化版本 4 257.9 45 结果解读 对如上测试结果进行解读。\n优化版本 1 相较于原始算法 优化版本 1 主要改进了每次搜索的广度。原始算法无论是否已经找到终点，都会持续进行搜索，直到对整张地图遍历完成，这样会造成大量不必要的时间开销。优化版本 1 则解决了这一问题，在搜索过程中，一旦找到终点，则立刻停止搜索，避免额外的时间开销。\n算法 usa_long 测试平均耗时 (ms) usa_short 测试平均耗时 (ms) 原始算法 2213.4 2197.7 优化版本 1 1089 165.2 观测实验结果，与我们的分析相符。由于原始算法无论如何都会对整张地图遍历，因此在两个测试集中的表现差异不大。而优化后的算法在两类测试集上的性能均有显著提升。尤其在搜索较短路径的 usa_short 测试中，优化后的算法在效率上要大大高于原始算法，甚至实现了数量级的飞跃。\n为较为明显地体现出搜索效率的差距，以下给出原始算法以及优化版本 1 中，搜索同一条最短路径时所搜索到的所有路径。其中，最短路径以红色标明，其他搜索到的路径以青色标明。\n原始算法 优化版本 1 优化版本 2 相较于优化版本 1 优化版本 1 的问题在于，尽管通过找到结果即时停止搜索的方式降低了复杂度，但每次搜索中初始化的过程仍占有相当的时间开销。优化版本 2 就对这一点进行了补充。\n算法 usa_long 测试平均耗时 (ms) usa_short 测试平均耗时 (ms) 优化版本 1 1089 165.2 优化版本 2 813.8 99.6 观察上述结果，在对初始化的开销进行优化为亚线性级别后，算法在两个测试集上的运行效率均得到了提升。在 usa_long 测试上提升达到 1.34x，在 usa_short 测试上的提升达到了 1.66x。\n优化版本 3 相较于优化版本 2 尽管通过两个版本的优化，算法的效率已经得到了大幅的提升，但每次我们的搜索仍然具有相当的盲目性，这体现在于我们没有充分利用节点之间的拓扑结构。优化版本 3 就在优化版本 2 的基础上，引入了解决这一问题的 A 算法*。通过这一启发性算法，能利用图本身的拓扑结构信息，对节点搜索的方向进行一个指向性的优化。\n算法 usa_long 测试平均耗时 (ms) usa_short 测试平均耗时 (ms) 优化版本 2 813.8 99.6 优化版本 3 199.3 42.1 观察实验结果，通过 A* 算法优化后的优化版本 3，在两类数据集上都迎来了巨大的效率提升。尤其在于测试长距离路径的 usa_long 测试集上的表现，相较于版本 2，优化幅度可达 4.1x。而在短距离路径测试集 usa_short 上也有着 2.4x 的效率提升。\n显然，A* 算法提供的指向性搜索，对长距离路径的优化更为显著，这一点无论是理论上还是测试得到的结果上都可以加以验证。以下同样给出搜索同一条最短路径时所搜索的所有路径的信息。\n可以看出，相较于版本 1，优化版本 3 中避免了更多不必要的搜索，提高了效率。\n优化版本 4 相较于优化版本3 这一版本的优化，相较于之前的版本迭代获取的效率提升而言，就有些不尽如人意。从实验的数据结果来看，这一优化甚至无益于提升效率，还会降低整体的算法效率。\n算法 usa_long 测试平均耗时 (ms) usa_short 测试平均耗时 (ms) 优化版本 3 199.3 42.1 优化版本 4 257.9 45 将优化版本 3 中以二叉堆实现的优先队列更换为优化版本 4 中以四叉堆实现的优先队列，从得到的测试结果来看，效率不仅没有提高，反而有略微的下降。通过对两种数据结构的分析，总结出以下原因。\nN 叉堆（N\u0026gt;2），相较二叉堆，优势有两点。\n节点上浮的操作更快。同样的上浮操作，N叉堆需要的比较次数只有二叉堆的 logN2 倍； 对缓存更友好。二叉堆对数组的访问范围更大，也更加随机，而N叉堆则更集中于数组的前部，这就对缓存更加友好。 但需要注意的是，尽管多叉堆有如上优点，数据结构往往需要在空间性能与节省性能之中做出权衡于取舍。具有如上优点的多叉堆的代价就在于，多叉堆在执行删除最小元素的操作时，需要的比较次数是二叉堆的 log2N 倍。\n不同的特点导致不同的应用场景，依据上述分析，二叉堆更加适合数据量较小，入队出队最更加频繁的场景；而多叉堆则更适合数据量较大，出队不太频繁的场景。我们需要根据应用场景，来选择最合适的数据结构。\n如本次实验的情形中，由于我们在 Dijkstra算法的搜索过程中，需要不断地取出并删除堆中的最小元素，因此对于 delMin() 操作的使用是相当频繁的。而这也正是多叉堆效率上不如二叉堆的原因。因此，优化版本 4 的实现效率反而不如采用二叉堆实现的优化版本 3 。\n分析总结 通过对原始 Dijkstra算法的不断优化改进，算法在面对大规模输入数据的情形下更加得心应手。在效率最高的优化版本 3 中，面对短路径数据集的效率提升达到了原始版本的 52x，面对长路径数据集的效率也提高到了原始版本的 11x。\n其中，优化版本 1，即一旦搜索到终点即结束搜索，对短路径搜索最短路径的效率提升极高；优化版本 3，即采用启发式算法改进搜索过程则对无论是短路径还是长路径的改进也都相当可观。\n美中不足之处在于，对于优化版本 4，即采用多路堆替代二叉堆实现优先队列，产生的效果不甚理想。通过查阅资料与对算法逻辑的分析，也查明了其原因。进一步认识到了数据结构的选用应该与实际应用场景所相适应。\n收获感想 在本次实验中，通过对原始 Dijkstra算法的不断改进，加强了我的实践编程能力，同时，更好地认识了 Dijkstra算法以及相关图算法的特点，初步了解了 A* 算法的理论和应用。同时，学会了针对不同的应用环境选用恰当的数据结构。\n附录 完整测试结果 原始 Dijkstra算法 轮次 usa_long 测试耗时 usa_short 测试耗时 1 2265 2196 2 2253 2205 3 2206 2181 4 2219 2187 5 2196 2205 6 2190 2215 7 2170 2202 8 2171 2213 9 2213 2186 10 2251 2187 平均值 2213.4 2197.7 优化版本 1 轮次 usa_long 测试耗时 usa_short 测试耗时 1 1071 163 2 1085 166 3 1073 166 4 1103 161 5 1076 185 6 1082 159 7 1083 163 8 1130 170 9 1084 161 10 1103 158 平均值 1089 165.2 优化版本 2 轮次 usa_long 测试耗时 usa_short 测试耗时 1 787 99 2 806 102 3 814 97 4 818 100 5 810 102 6 811 99 7 833 99 8 809 104 9 829 97 10 821 97 平均值 813.8 99.6 优化版本 3 轮次 usa_long 测试耗时 usa_short 测试耗时 1 195 40 2 197 41 3 204 41 4 198 39 5 201 40 6 198 39 7 205 49 8 197 45 9 202 47 10 196 40 平均值 199.3 42.1 优化版本 4 轮次 usa_long 测试耗时 usa_short 测试耗时 1 253 43 2 257 43 3 258 43 4 257 45 5 257 48 6 257 47 7 262 43 8 260 43 9 258 47 10 260 48 平均值 257.9 45 实验程序 Dijkstra_0 原始算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Dijkstra\u0026#39;s algorithm to find shortest path from s to d private void dijkstra(int s, int d) { int V = G.V(); // 初始化 deleted = new LinkedList\u0026lt;Integer\u0026gt;(); dist = new double[V]; pred = new int[V]; for (int v = 0; v \u0026lt; V; v++) dist[v] = INFINITY; for (int v = 0; v \u0026lt; V; v++) pred[v] = -1; // 优先队列创建并初始化 IndexPQ pq = new IndexPQ(V); for (int v = 0; v \u0026lt; V; v++) pq.insert(v, dist[v]); // 设立源点 dist[s] = 0.0; pred[s] = s; pq.change(s, dist[s]); // Dijkstra 算法 while (!pq.isEmpty()) { int v = pq.delMin(); deleted.add(v); // 当 v 点不可达时退出循环 if (pred[v] == -1) break; // 遍历所有 v 点的邻居 IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 如果新的距离更短，则更新距离 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) { dist[w] = dist[v] + G.distance(v, w); pq.change(w, dist[w]); pred[w] = v; } } } } Dijkstra_1 优化版本 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* 改进 1：一旦找到目标点，立刻结束搜索 */ private void dijkstra(int s, int d) { int V = G.V(); dist = new double[V]; pred = new int[V]; for (int v = 0; v \u0026lt; V; v++) dist[v] = INFINITY; // 距离初始化为无穷大 for (int v = 0; v \u0026lt; V; v++) pred[v] = -1; IndexPQ pq = new IndexPQ(V); for (int v = 0; v \u0026lt; V; v++) pq.insert(v, dist[v]); // set distance of source 设定源点到达源点的距离为 0，源点到源点的前一个结点为本身 dist[s] = 0.0; pred[s] = s; pq.change(s, dist[s]); // 修改优先队列里的源点 // run Dijkstra\u0026#39;s algorithm 运行 Dijkstra 算法 while (!pq.isEmpty()) { // 取出 pq 中的排序的 dist 最小的结点，并将结点从队列中出列 int v = pq.delMin(); // v not reachable from s so stop 结点不可达时，结束循环，不用深究这个 if (pred[v] == - 1) break; // scan through all nodes w adjacent to v 查找所有与 v 相邻的 w 节点，分别做处理 // 用迭代器遍历 G 的 neighbors IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 如果得到新的距离要比原来更近，则更新长度和路径 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) { dist[w] = dist[v] + G.distance(v, w); pq.change(w, dist[w]); pred[w] = v; } } if (v == d) break; } } Dijkstra_2 优化版本 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Dijkstra\u0026#39;s algorithm to find shortest path from s to d /* 改进 2：在改进 1 的基础上将初始化时间优化为压线性 */ private void dijkstra(int s, int d) { int V = G.V(); // 对队列内的点进行初始化 while (!changed.isEmpty()) { int v = changed.poll(); dist[v] = INFINITY; pred[v] = -1; } pq = new IndexPQ(V); dist[s] = 0.0; pred[s] = s; changed.add(s); pq.insert(s, dist[s]); while (! pq.isEmpty()) { int v = pq.delMin(); if (v == d || pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 如果得到新的距离要比原来更近，则更新长度和路径 if (dist[v] + G.distance(v, w) \u0026lt; dist[w] - EPSILON) { // 若该点重来没有被遍历过，将其加入优先队列pq，否则修改其在优先队列内的数值 if (dist[w] != INFINITY) { dist[w] = dist[v] + G.distance(v, w); pq.change(w, dist[w]); } else { dist[w] = dist[v] + G.distance(v, w); pq.insert(w, dist[w]); // 将其加入队列，标记该点已被修改 changed.add(w); } pred[w] = v; } } } } Dijkstra_3 优化版本 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Dijkstra\u0026#39;s algorithm to find shortest path from s to d /* 改进 3：在改进 2 的基础上，更改为 A* 算法，即启发性搜索 */ private void dijkstra(int s, int d) { int V = G.V(); while (!changed.isEmpty()) { int v = changed.poll(); dist[v] = INFINITY; pred[v] = -1; } pq = new IndexPQ(V); dist[s] = 0.0; pred[s] = s; changed.add(s); pq.insert(s, dist[s]); // run Dijkstra\u0026#39;s algorithm 运行 Dijkstra 算法 while (! pq.isEmpty()) { int v = pq.delMin(); if (v == d || pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); // 将d[w]更新为d[v] + 从v到w的距离 + 从w到d的欧式距离 - 从v到d的欧式距离 if (dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d) \u0026lt; dist[w] - EPSILON) { if (dist[w] != INFINITY) { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.change(w, dist[w]); } else { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.insert(w, dist[w]); changed.add(w); } pred[w] = v; } } } } Dijkstra_4 优化版本 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Dijkstra\u0026#39;s algorithm to find shortest path from s to d /* 改进 4：在改进 3 的基础上，优先队列采用多路堆实现 */ private void dijkstra(int s, int d) { int V = G.V(); while (!changed.isEmpty()) { int v = changed.poll(); dist[v] = INFINITY; pred[v] = -1; } IndexMultiwayMinPQ\u0026lt;Double\u0026gt; pq = new IndexMultiwayMinPQ\u0026lt;Double\u0026gt;(V, WAYS); dist[s] = 0.0; pred[s] = s; changed.add(s); pq.insert(s, dist[s]); while (! pq.isEmpty()) { int v = pq.delMin(); if (v == d || pred[v] == - 1) break; IntIterator i = G.neighbors(v); while (i.hasNext()) { int w = i.next(); if (dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d) \u0026lt; dist[w] - EPSILON) { if (dist[w] != INFINITY) { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.changeKey(w, dist[w]); } else { dist[w] = dist[v] + G.distance(v, w) + G.distance(w, d) - G.distance(v, d); pq.insert(w, dist[w]); changed.add(w); } pred[w] = v; } } } } ShortestPath 获取最短路并绘图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ShortestPath { public static void main(String[] args) { Turtle.create(1000, 700); String file = \u0026#34;\u0026#34;;\t// usa.txt // read in the graph from a file In graphin = new In(file); EuclideanGraph G = new EuclideanGraph(graphin); System.err.println(\u0026#34;Done reading the graph \u0026#34; + file); System.err.println(\u0026#34;Enter query pair from stdin\u0026#34;); G.draw(); // read in the s-d pair from standard input Dijkstra_0 dijkstra = new Dijkstra_0(G); int s = StdIn.readInt(); int d = StdIn.readInt(); dijkstra.showPath(s, d); dijkstra.drawPath(s, d); Turtle.render(); } } PerformanceTest 测试各版本算法表现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public static void main(String[] args) throws IOException { String file = \u0026#34;\u0026#34;;\t// usa.txt File lf = new File(\u0026#34;\u0026#34;);\t// usa-long100.txt File sf = new File(\u0026#34;\u0026#34;);\t// usa-short100.txt Scanner ls = new Scanner(lf); Scanner ss = new Scanner(sf); long startTime, endTime; // read in the graph from a file In graphin = new In(file); EuclideanGraph G = new EuclideanGraph(graphin); Dijkstra_0 dijkstra_0 = new Dijkstra_0(G); Dijkstra_1 dijkstra_1 = new Dijkstra_1(G); Dijkstra_2 dijkstra_2 = new Dijkstra_2(G); Dijkstra_3 dijkstra_3 = new Dijkstra_3(G); Dijkstra_4 dijkstra_4 = new Dijkstra_4(G); // 对算法进行 usa-long100.txt 数据集的测试 System.out.println(\u0026#34;version 0, usa_long.txt\u0026#34;); for (int i = 0; i \u0026lt; TIMES; i++) { ls = new Scanner(lf); startTime = System.currentTimeMillis(); while (ls.hasNext()) { int s = ls.nextInt(); int d = ls.nextInt(); dijkstra_0.distance(s, d); } endTime = System.currentTimeMillis(); if (i \u0026gt; 0) System.out.println(endTime - startTime); } // 对算法进行 usa-short100.txt 数据集的测试 System.out.println(\u0026#34;version 0, usa_short.txt\u0026#34;); for (int i = 0; i \u0026lt; TIMES; i++) { ss = new Scanner(sf); startTime = System.currentTimeMillis(); while (ss.hasNext()) { int s = ss.nextInt(); int d = ss.nextInt(); dijkstra_0.distance(s, d); } endTime = System.currentTimeMillis(); if (i \u0026gt; 0) System.out.println(endTime - startTime); } } ","date":"2022-02-03T16:12:52Z","image":"https://TuJin07.github.io/p/%E5%9C%B0%E5%9B%BE%E8%B7%AF%E7%94%B1map-routing/cover_huc13785305f2408b6fafb21eff69213c9_3568700_120x120_fill_q75_box_smart1.jpeg","permalink":"https://TuJin07.github.io/p/%E5%9C%B0%E5%9B%BE%E8%B7%AF%E7%94%B1map-routing/","title":"地图路由(Map Routing)"},{"content":"几种排序算法的实验性能比较 问题描述 实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。在你的计算机上针对不同输入规模数据进行实验，对比上述排序算法的时间性能。要求对于每次输入运行10次，记录每次时间，取平均值。\n记录 Comparison of running time of sorting algorithms (in Micro Seconds)\ni Run1 Run2 Run3 Run4 Run5 Run6 Run7 Run8 Run9 Run10 Average IS TDM BUM RQ QD3P 回答问题 Which sort worked best on data in constant or increasing order (i.e., already sorted data)? Why do you think this sort worked best?\nDid the same sort do well on the case of mostly sorted data? Why or why not?\nIn general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer.\nWhich sort did best on the shorter (i.e., n = 1,000) data sets? Did the same one do better on the longer (i.e., n = 10,000) data sets? Why or why not? Please use specific data from your table to support your answer.\nIn general, which sort did better? Give a hypothesis as to why the difference in performance exists.\nAre there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this {1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5] the 7.0 entry is not consistent with the rest). Why do you think this happened?\n问题分析 实现五种不同的排序算法，对其加以优化，使其具有尽可能高的性能。再挑选不同的具有各自特点的数据集对排序算法的性能进行测试，记录测试结果，加以对比，结合数据结果和理论分析，综合回答上述提出的问题。\n实现细节 IS 插入排序 1 2 3 4 5 6 7 8 9 10 11 public static void sort(int[] nums, int begin, int end) { for (int i = begin + 1; i \u0026lt; end; i++) { int temp = nums[i]; int j = i; while (j \u0026gt; begin \u0026amp;\u0026amp; temp \u0026lt; nums[j - 1]) { nums[j] = nums[j - 1]; j = j - 1; } nums[j] = temp; } } TDM 自顶向下归并排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class TopDownMergeSort { /* less than the value and switch to insertion sort */ private static final int INSERTION_SORT_THRESHOLD = 7; /* only one temporary array is used throughout */ private static int[] temp; public static void sort(int[] nums) { temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1); } /* subarray boundary * left subarray:[left, mid] * right subarray:[mid + 1, right] * */ private static void mergeSort(int[] nums, int left, int right) { /* switch to insertion sort */ if (right - left \u0026lt;= INSERTION_SORT_THRESHOLD) { InsertionSort.sort(nums, left, right + 1); return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); /* already ordered */ if (nums[mid] \u0026lt;= nums[mid + 1]) return; merge(nums, left, mid, right); } private static void merge(int[] nums, int left, int mid, int right) { int i = left; int j = mid + 1; for (int k = 0; k \u0026lt; right - left + 1; k++) { if (i == mid + 1) { temp[k] = nums[j++]; continue; } if (j == right + 1) { temp[k] = nums[i++]; continue; } if (nums[i] \u0026lt;= nums[j]) { temp[k] = nums[i++]; } else { temp[k] = nums[j++]; } } System.arraycopy(temp, 0, nums, left, right - left + 1); } } 上述的归并排序实现算法，代码上做了以下几点优化：\n小区间内转入插入排序，效率更高。 两个子数组本身有序的情况下，无需合并，处理有序数组时能到达线性级别。 全程使用一份临时数组 temp，不造成额外创建与销毁数组的开销。 实现治的过程，将算法实现为稳定排序。 BUM 自底向上归并排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class BottomUpMergeSort { private static int[] temp; public static void sort(int[] nums) { temp = new int[nums.length]; mergeSort(nums); } /* subarray boundary * left subarray:[left, mid] * right subarray:[mid + 1, right] * */ private static void mergeSort(int[] nums) { for (int sz = 1; sz \u0026lt; nums.length; sz *= 2) { int lo = 0; while (lo \u0026lt; nums.length - sz) { /* if sub-arrays are out of order, enter merge */ if (nums[lo + sz - 1] \u0026gt; nums[lo + sz]) merge(nums, lo, lo + sz - 1, Math.min(lo + sz * 2 - 1, nums.length - 1)); lo += sz * 2; } } } private static void merge(int[] nums, int left, int mid, int right) { int i = left; int j = mid + 1; for (int k = 0; k \u0026lt; right - left + 1; k++) { if (i == mid + 1) { temp[k] = nums[j++]; continue; } if (j == right + 1) { temp[k] = nums[i++]; continue; } if (nums[i] \u0026lt;= nums[j]) { temp[k] = nums[i++]; } else { temp[k] = nums[j++]; } } System.arraycopy(temp, 0, nums, left, right - left + 1); } } 自底向上的归并排序同样做了以下几点优化：\n两个子数组本身有序的情况下，无需合并，处理有序数组时能到达线性级别。 全程使用一份临时数组 temp，不造成额外创建与销毁数组的开销。 实现治的过程，将算法实现为稳定排序。 RQ 随机快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class RandomQuicksort { /* less than the value and switch to insertion sort */ private static final int INSERTION_SORT_THRESHOLD = 7; /* subarray boundary * left subarray:[lo, j - 1] * right subarray:[j + 1, hi] * */ private static void quickSort(int[] nums, int lo, int hi) { /* switch to insertion sort */ if (hi - lo + 1 \u0026lt;= INSERTION_SORT_THRESHOLD) { InsertionSort.sort(nums, lo, hi + 1); return; } int j = partition(nums, lo, hi); quickSort(nums, lo, j - 1); quickSort(nums, j + 1, hi); } @SuppressWarnings(\u0026#34;StatementWithEmptyBody\u0026#34;) private static int partition(int[] nums, int left, int right) { /* randomly select pivot */ int pivot = (int) (Math.random() * (right - left) + left); swap(nums, left, pivot); int i = left, j = right + 1; while (true) { while (++ i \u0026lt;= right \u0026amp;\u0026amp; nums[i] \u0026lt; nums[left]) ; while (-- j \u0026gt; left \u0026amp;\u0026amp; nums[j] \u0026gt; nums[left]) ; if (j \u0026lt;= i) break; swap(nums, i, j); } swap(nums, left, j); return j; } private static void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } public static void sort(int[] nums) { quickSort(nums, 0, nums.length - 1); } } 随机快排的实现具备了以下特点：\n小区间内转入插入排序，效率更高。 随机化选择切分元素，避免进入最坏情况。 QD3P Djikstra 3-路划分快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class ThreeWayPartitionQuickSort { private static final int INSERTION_SORT_THRESHOLD = 7; public static void sort(int[] nums) { quickSort(nums, 0, nums.length - 1); } /* * [lo, lt) \u0026lt; temp * [lt, i) == temp * (gt, hi] \u0026gt; temp * */ private static void quickSort(int[] nums, int lo, int hi) { /* switch to insertion sort */ if (hi - lo + 1 \u0026lt;= INSERTION_SORT_THRESHOLD) { InsertionSort.sort(nums, lo, hi + 1); return; } /* randomly select pivot */ int pivot = (int) (Math.random() * (hi - lo) + lo); swap(nums, lo, pivot); int lt = lo; int gt = hi; int i = lo + 1; int temp = nums[lo]; while (gt \u0026gt;= i) { if (nums[i] \u0026lt; temp) { swap(nums, i++, lt++); } else if (nums[i] \u0026gt; temp) { swap(nums, i, gt--); } else { i++; } } quickSort(nums, lo, lt - 1); quickSort(nums, gt + 1, hi); } private static void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } 三路划分快速排序实现同样具有以下特点：\n小区间内转入插入排序，效率更高。 随机化选择切分元素，避免进入最坏情况。 实验结果 测试环境 CPU: AMD Ryzen 5 5600U with 2.30Ghz\nRAM: 16.0 GB\nOS: Windows 11\n测试数据 共计 10 轮测试，我们准备了 10 个不同的数据集，每轮测试的结果记录为当前算法在当前数据集上运行 10 次后得到的平均值。\n为充分辨别不同排序算法间的差距，我们规定了以下具有不同特点的测试数据集，假设 n 为测试数组长度。\n第 1 轮 ~ 第 4 轮：n 分别为 [0.5k, 1k, 10k, 100k] 的随机数组。 第 5 轮 ~ 第 6 轮：n 为 1M 的随机数组。 第 7 轮：n 为 100k 的已经排好序的正序数组。 第 8 轮：n 为 100k 的已经排好序的逆序数组。 第 9 轮：n 为 100k 的有大量重复元素的随机数组。 第 10 轮：n 为 100k 的单值数组（所有元素的值相同的数组）。 结果记录 每轮数据的记录均为在程序在当前数据集情况下重复运行 10 次的情况下取的平均值。 为了更直观看出运行时间的区别，我们使用毫秒而不是微秒为时间记录单位，即时间记录单位为 ms。 TLE 表示运行超时，程序耗时在 60 s 以上（实际上比这个值要大得多），计算平均值时取 TLE = 60000 ms 。 对上述所有测试数据集进行测试，得到的结果记录如下。\nIS TDM BUM RQ QD3P Run 1 5.10 1.34 1.33 1.15 1.25 Run 2 7.81 1.93 1.88 1.95 2.10 Run 3 32.86 3.83 4.85 5.31 4. 60 Run 4 1635.10 20.41 33.05 29.83 45.21 Run 5 TLE 207.24 221.52 179.90 178.41 Run 6 TLE 203.10 242.77 187.85 218.53 Run 7 4.75 2.31 6.91 18.98 30.48 Run 8 2911.23 11.05 24.71 22.14 25.60 Run 9 1524.65 22.06 24.32 24.11 7.83 Run 10 4.32 6.32 7.69 23.97 4.01 Average 12612.58 48.66 56.90 49.52 57.05 问题回答 Which sort worked best on data in constant or increasing order (i.e., already sorted data)? Why do you think this sort worked best? 以下将依据测试结果中的第 7 轮、第 8 轮以及第 10 轮（分为别同规模大小的正序数组，逆序数组，单值数组）分析。\nIS TDM BUM RQ QD3P Run 7 4.75 2.31 6.91 18.98 30.48 Run 8 2911.23 11.05 24.71 22.14 25.60 Run 10 4.32 6.32 7.69 23.97 4.01 正序数组\n对于已经有序且正序的数组，从实验结果中的第 7 轮来看，较高效的排序方式为 IS。理论上，在数组近乎正序的前提下，IS 的时间复杂度接近线性级别，这也与我们的测试结果符合。\n同时，添加了剪枝优化的两种归并排序 TDM 和 BUM，在面对已经正序排列的数据时也能达到线性级别的表现，而两种快排对此的表现就不甚理想。\n逆序数组\n对于已经有序且逆序的数组，从实现结果第 8 轮来看，各种排序方法的时间开销与第 4 轮的同样输入规模的随机数组相比变化不大。\n单值数组\n对于单值数组，由于其也是一种特殊的正序数组，因此 IS 对于单值数组的排序也具有较高的效率。同时，剪枝优化后的两种归并排序也有很好的表现。\n而快排中的 QD3P 是专门为大量同值元素所优化过的快排算法，在面对单值数组时也表现优秀。\nDid the same sort do well on the case of mostly sorted data? Why or why not? 依据测试结果中的第 4 轮（输入规模大小为 100k 的随机数组）与第 7 轮（输入规模大小为 100k 的正序数组）与第 8 轮（输入规模大小为 100k 的逆序数组）进行分析。\nIS TDM BUM RQ QD3P Run 4 1635.10 20.41 33.05 29.83 45.21 Run 7 4.75 2.31 6.91 18.98 30.48 Run 8 2911.23 11.05 24.71 22.14 25.60 可以看出，在输入规模相同的情形下，相对于排序随机数组，**IS **，**剪枝优化后的归并排序 TDM 与 BUM **在处理已经正序排序的数组上表现更佳。\n而两种快速排序由于采取了随机化选取切分元素的改进方法，使得时间开销在排序正序数组与排序随机数组上的区别不大，没有退化为 O(n2)。\n对于逆序数组，几种排序算法在处理的时间开销上与处理随机数组没有显著区别。\nIn general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer. 依据测试结果中的第 4 轮（输规模大小为 100k 的随机数组）与第 7 轮（输入规模大小为 100k 的正序数组）与第 8 轮（输入规模大小为 100k 的逆序数组）进行分析。\nIS TDM BUM RQ QD3P Run 4 1635.10 20.41 33.05 29.83 45.21 Run 7 4.75 2.31 6.91 18.98 30.48 Run 8 2911.23 11.05 24.71 22.14 25.60 参照数据，可以认为 IS，剪枝优化后的 TDM 与 BUM 在处理正序数据上会有更高的性能；在理论分析上，这些算法处理几乎正序的数据时时间开销可以接近线性级别，实验结果与理论分析也吻合。\n而两种快速排序由于实现特点，其对于有序的数据处理性能并没有与随机数据处理性能有明显差距。且几种排序算法对于逆序数据的处理与随机数据处理在时间开销上近似。\nWhich sort did best on the shorter (i.e., n = 1,000) data sets? Did the same one do better on the longer (i.e., n = 10,000) data sets? Why or why not? Please use specific data from your table to support your answer. 理论分析上认为，在应对小规模数据的排序处理上，插入排序 IS 由于每个元素与最终排定位置相距不远，因此其会有较高的效率，但插入排序并不适合处理较大规模的数据。\n不过很遗憾的是，我的测试数据集得到的结果并不足以说明这一点，以下我将说明我测试得到的结果以及我认为的原因。\n以下列出输入规模 n 分别为 [0.5k, 1k, 10k, 100k] 的随机数组测试数据。\nIS TDM BUM RQ QD3P Run 1 5.10 1.34 1.33 1.15 1.25 Run 2 7.81 1.93 1.88 1.95 2.10 Run 3 32.86 3.83 4.85 5.31 4. 60 Run 4 1635.10 20.41 33.05 29.83 45.21 从数据上的结果可以得出的结论是，四种输入规模的数据，n 从 0.5k 增长到 100k，对与每一种输入规模的数据测试结果。\n四种理论时间复杂度表现为 O(nlgn) 的排序算法的花销时间上的差别不大，都处于同一数量级；且在处理小规模输入与大规模输入的情形下保持着同样优秀的表现。 理论时间复杂度表现为 O(n2) 的 IS 无论在小规模还是大规模输入情况下，表现都劣于其余四种算法；且数据输入规模越大，所使用的时间开销增长越大。 对于以上结果，整体符合理论上预期，唯独 插入排序 IS 在处理小规模输入数据上并没有表现得更好，在此我做几点我的分析。\nn 为 0.5k 或是 1k 的输入规模，对于插入排序而言还是过大，达不到所谓小规模输入的要求，因此表现不如预期。 对于其余几种归并排序、快速排序的算法实现上，在实现过程中我做了一点优化：在划分得到子数组长度较小时，转入使用插入排序。我认为因为这一点，IS 插入排序 与其余几种优化后的排序算法对于小规模输入处理在时间开销上拉不开差距。 总之，总结以上分析，可以认为 IS 在处理小规模数据上可以拥有比较好的表现，而在更大规模的数据上则表现不佳；优化后的归并排序与快速排序，无论是对小规模数据还是大规模数据的处理，都能维持一个较好的表现。\nIn general, which sort did better? Give a hypothesis as to why the difference in performance exists. 参考对于 10 轮输入数据的平均处理时间。\nIS TDM BUM RQ QD3P Average 12612.58 48.66 56.90 49.52 57.05 可以认为一般而言，IS 的表现欠佳，其余四种时间复杂度为 O(nlgn) 的排序算法表现都更好，且差距不大，不过对于特殊的数据各有优势。\nQD3P 在处理有大量重复值的输入数据上相比于其他排序算法更有优势；TDM, BUM 两种归并排序算法在剪枝优化后对于处理几乎有序的数据上表现更佳；快速排序在空间开销以及通常情况下的泛用性而言要好于归并排序；归并排序在算法的稳定上要优于快速排序。\nAre there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this {1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5] the 7.0 entry is not consistent with the rest). Why do you think this happened? 为了验证这个问题，我们在输入规模 n 为 100k 的情况下再连续进行 10 轮实验，记录第二份实验结果，如下。\nIS TDM BUM RQ QD3P Run 11 1753.43 22.90 28.56 26.09 31.59 Run 12 1612.72 15.12 17.60 13.97 14.70 Run 13 1587.22 14.72 20.29 14.19 17.12 Run 14 1632.38 14.36 16.18 13.46 14.50 Run 15 1712.36 14.22 16.02 14.05 15.81 Run 16 1725.60 14.32 15.92 13.38 14.17 Run 17 1649.61 14.41 15.72 13.27 13.76 Run 18 1687.42 14.37 16.13 13.53 14.07 Run 19 1686.69 14.34 16.21 14.93 15.79 Run 20 1651.76 14.46 15.83 13.76 14.85 依据上述实验结果表格进行分析，我们发现，经过多次重复的十轮实验，**每一次重复实验的第 1 轮中，各种排序算法的运行时间整体都偏长。**除开第 1 轮实验，后面多轮实验的各种排序算法运行时间整体一致，并未出现题目所说的有不一致的结果。\n通过合理推断与查阅文献，对于以上结果做如下分析：\n每次重复实验中第 1 轮运行时间偏高，是因为 CPU 在首次处理该内存段地址的数据时需要建立 TLB，将数据引入 Cache 中，这一操作影响了首轮排序的处理时间。 在往后多轮的排序中，并不需要重复为同一段内存地址的数据建立 TLB，同时通过 TLB 直接访问数据，可以大大加快程序的处理速度。 除此之外，虽然我的测试中并没有出现题目所言运行时间不一致的情况。但我个人认为，若如题目所言，出现运行时间不一致的情况，我们有理由假设是其**遇到了某些特殊的数据：比如前面讨论过的大致有序的数组，或是含有较多重复值得数组。**这些会造成特定算法在处理时间上具有很大的差异性，这一点在我们的第一份测试结果中也可以体现。\nIS TDM BUM RQ QD3P Run 4 1635.10 20.41 33.05 29.83 45.21 Run 7 4.75 2.31 6.91 18.98 30.48 复杂度分析 IS 插入排序 时间复杂度 O(n2) 空间复杂度 O(1) TDM 自顶向下归并排序 时间复杂度 O(nlgn) 空间复杂度 O(n) BUM 自底向上归并排序 时间复杂度 O(nlgn) 空间复杂度 O(n) RQ 随机快速排序 时间复杂度 O(nlgn) 空间复杂度 O(lgn)，主要来源于递归栈调用 QD3P Djistra 3-路划分快速排序 时间复杂度 O(nlgn) 空间复杂度 O(lgn)，主要来源于递归栈调用 收获感想 在本次实验中，通过实现不同类型的排序算法，加强了我的实践编程能力，同时更好地认识了不同算法的实现细节与运行特点。学会了针对不同输入数据采取有不同特点的排序算法以获得最好的性能表现。\n完整程序 IS 插入排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package sort; /** * @author wang yuxuan * @create 2021.10.20 */ public class InsertionSort { public static void sort(int[] nums) { sort (nums, 0, nums.length); } public static void sort(int[] nums, int begin, int end) { for (int i = begin + 1; i \u0026lt; end; i++) { int temp = nums[i]; int j = i; while (j \u0026gt; begin \u0026amp;\u0026amp; temp \u0026lt; nums[j - 1]) { nums[j] = nums[j - 1]; j = j - 1; } nums[j] = temp; } } } TDM 自顶向下归并排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package sort; /** * @author wang yuxuan * @create 2021.10.21 */ public class TopDownMergeSort { /* less than the value and switch to insertion sort */ private static final int INSERTION_SORT_THRESHOLD = 7; /* only one temporary array is used throughout */ private static int[] temp; public static void sort(int[] nums) { temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1); } /* subarray boundary * left subarray:[left, mid] * right subarray:[mid + 1, right] * */ private static void mergeSort(int[] nums, int left, int right) { /* switch to insertion sort */ if (right - left \u0026lt;= INSERTION_SORT_THRESHOLD) { InsertionSort.sort(nums, left, right + 1); return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); /* already ordered */ if (nums[mid] \u0026lt;= nums[mid + 1]) return; merge(nums, left, mid, right); } private static void merge(int[] nums, int left, int mid, int right) { int i = left; int j = mid + 1; for (int k = 0; k \u0026lt; right - left + 1; k++) { if (i == mid + 1) { temp[k] = nums[j++]; continue; } if (j == right + 1) { temp[k] = nums[i++]; continue; } if (nums[i] \u0026lt;= nums[j]) { temp[k] = nums[i++]; } else { temp[k] = nums[j++]; } } System.arraycopy(temp, 0, nums, left, right - left + 1); } } BUM 自底向上归并排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package sort; /** * @author wang yuxuan * @create 2021.11.01 */ public class BottomUpMergeSort { private static int[] temp; public static void sort(int[] nums) { temp = new int[nums.length]; mergeSort(nums); } /* subarray boundary * left subarray:[left, mid] * right subarray:[mid + 1, right] * */ private static void mergeSort(int[] nums) { for (int sz = 1; sz \u0026lt; nums.length; sz *= 2) { int lo = 0; while (lo \u0026lt; nums.length - sz) { /* if sub-arrays are out of order, enter merge */ if (nums[lo + sz - 1] \u0026gt; nums[lo + sz]) merge(nums, lo, lo + sz - 1, Math.min(lo + sz * 2 - 1, nums.length - 1)); lo += sz * 2; } } } private static void merge(int[] nums, int left, int mid, int right) { int i = left; int j = mid + 1; for (int k = 0; k \u0026lt; right - left + 1; k++) { if (i == mid + 1) { temp[k] = nums[j++]; continue; } if (j == right + 1) { temp[k] = nums[i++]; continue; } if (nums[i] \u0026lt;= nums[j]) { temp[k] = nums[i++]; } else { temp[k] = nums[j++]; } } System.arraycopy(temp, 0, nums, left, right - left + 1); } } RQ 随机快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package sort; /** * @author wang yuxuan * @create 2021.10.31 */ public class RandomQuicksort { /* less than the value and switch to insertion sort */ private static final int INSERTION_SORT_THRESHOLD = 7; /* subarray boundary * left subarray:[lo, j - 1] * right subarray:[j + 1, hi] * */ private static void quickSort(int[] nums, int lo, int hi) { /* switch to insertion sort */ if (hi - lo + 1 \u0026lt;= INSERTION_SORT_THRESHOLD) { InsertionSort.sort(nums, lo, hi + 1); return; } int j = partition(nums, lo, hi); quickSort(nums, lo, j - 1); quickSort(nums, j + 1, hi); } @SuppressWarnings(\u0026#34;StatementWithEmptyBody\u0026#34;) private static int partition(int[] nums, int left, int right) { /* randomly select pivot */ int pivot = (int) (Math.random() * (right - left) + left); swap(nums, left, pivot); int i = left, j = right + 1; while (true) { while (++ i \u0026lt;= right \u0026amp;\u0026amp; nums[i] \u0026lt; nums[left]) ; while (-- j \u0026gt; left \u0026amp;\u0026amp; nums[j] \u0026gt; nums[left]) ; if (j \u0026lt;= i) break; swap(nums, i, j); } swap(nums, left, j); return j; } private static void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } public static void sort(int[] nums) { quickSort(nums, 0, nums.length - 1); } } QD3P 三路划分快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package sort; /** * @author wang yuxuan * @create 2021.11.01 */ public class ThreeWayPartitionQuickSort { private static final int INSERTION_SORT_THRESHOLD = 7; public static void sort(int[] nums) { quickSort(nums, 0, nums.length - 1); } /* * [lo, lt) \u0026lt; temp * [lt, i) == temp * (gt, hi] \u0026gt; temp * */ private static void quickSort(int[] nums, int lo, int hi) { /* switch to insertion sort */ if (hi - lo + 1 \u0026lt;= INSERTION_SORT_THRESHOLD) { InsertionSort.sort(nums, lo, hi + 1); return; } /* randomly select pivot */ int pivot = (int) (Math.random() * (hi - lo) + lo); swap(nums, lo, pivot); int lt = lo; int gt = hi; int i = lo + 1; int temp = nums[lo]; while (gt \u0026gt;= i) { if (nums[i] \u0026lt; temp) { swap(nums, i++, lt++); } else if (nums[i] \u0026gt; temp) { swap(nums, i, gt--); } else { i++; } } quickSort(nums, lo, lt - 1); quickSort(nums, gt + 1, hi); } private static void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; } } ","date":"2022-01-15T14:30:30Z","image":"https://TuJin07.github.io/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/cover_hu20ccea9eb23f4fac4fbcfe2eebe08c1d_11962038_120x120_fill_q75_box_smart1.JPG","permalink":"https://TuJin07.github.io/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/","title":"排序算法的实验性能比较"},{"content":"渗透问题(Percolation) 问题描述 使用 合并-查找（union-find） 数据结构，编写程序通过蒙特卡罗模拟（Monte Carlo simulation）来估计渗透阈值的值。\n模型 我们使用 N × N 网格点来模型一个渗透系统。 每个格点或是 open格点 或是 blocked格点 。 一个 full site 是一个 open格点 ，它可以通过一连串的邻近（左，右，上，下） open格点 连通到顶行的一个 open格点 。如果在底行中有一个 full site 格点 ，则称系统是渗透的。\n问题 在一个著名的科学问题中，研究人员对以下问题感兴趣：如果将格点以空置概率 p 独立地设置为 open格点 （因此以概率 1 - p 被设置为 blocked 格点），系统渗透的概率是多少？ 当 p = 0 时，系统不会渗出; 当 p = 1 时，系统渗透。 下图显示了 20 × 20 随机网格（左）和 100 × 100 随机网格（右）的格点空置概率p与渗滤概率。\n当 N 足够大时，存在阈值 p* ，使得当 p \u0026lt; p* ，随机 N x N 网格几乎不会渗透，并且当 p \u0026gt; p* 时，随机 N x N 网格几乎总是渗透。 尚未得出用于确定渗滤阈值 p* 的数学解。你的任务是编写一个计算机程序来估计 p*。\n问题分析 实现框架分析 依据实验要求文档，本次实验要求实现两个数据类型：Percolation 与 PercolationStats 。\nPercolation 数据类型 Percolation 为渗透问题的模型，可以进行渗透问题的模拟。要求文档中具体定义的 API 如下：\n1 2 3 4 5 6 7 8 public class Percolation { public Percolation(int N) // create N-by-N grid, with all sites blocked public void open(int i, int j) // open site (row i, column j) if it is not already public boolean isOpen(int i, int j) // is site (row i, column j) open? public boolean isFull(int i, int j) // is site (row i, column j) full? public boolean percolates() // does the system percolate? public static void main(String[] args) // test client, optional } 对于实现的细节，文档中还提出了如下要求：\n约定行 i 列 j 下标在 1 和 N 之间，其中 (1, 1) 为左上格点位置。 如果 open() , isOpen() , or isFull() 不在规定的范围，则抛出 IndexOutOfBoundsException 异常。 如果 N ≤ 0，构造函数应该抛出 IllegalArgumentException 异常。 构造函数应该与N2成正比。所有方法应该为常量时间加上常量次调用合并-查找方法 union() , find() , connected() , and count() 。 PercolationStats 数据类型 PercolationStats 用于执行一系列计算实验，应该提供以下 API：\n1 2 3 4 5 6 7 8 public class PercolationStats { public PercolationStats(int N, int T) // perform T independent computational experiments on an N-by-N grid public double mean() // sample mean of percolation threshold public double stddev() // sample standard deviation of percolation threshold public double confidenceLo() // returns lower bound of the 95% confidence interval public double confidenceHi() // returns upper bound of the 95% confidence interval public static void main(String[] args) // test client, described below } 此外，文档中还提出了如下要求：\n在N ≤ 0或T ≤ 0时，构造函数应该抛出 java.lang.IllegalArgumentException 异常。 包括一个 main() 方法，它取两个命令行参数 N 和 T ，在 N × N 网格上进行 T 次独立的计算实验（上面讨论），并打印出均值 μ 、标准差 σ 和 95％ 渗透阈值的置信区间。 使用标准库中的标准随机数生成随机数，使用标准统计库来计算样本均值和标准差。 实现算法分析 渗透问题可以与课堂所讲的 动态连通性 问题所相联系，每当开通一个 stie 后，则需要将其与周边的已开通 site 所相连，划分为同一个连通分量。\n关于 Percolation 数据类型的实现，需要用到并查集，因此还需要实现 union-find 算法。定义其 API ：\n1 2 3 4 5 6 7 public class unionFind { public unionFind(int N); public void union(int p, int q); public int find(int p); boolean connected(int p, int q); int count(); } 关于 union-find 算法的具体实现，我们将分别采用两种实现方式：quick-find 算法，weighted quick-union 算法，并对比其执行效率。\n数据结构分析 选择合适的数据结构载体，往往是解决问题的关键之一。本题与传统的动态连接问题的区别在于，该题不仅仅需要在 union-find 算法中维护一个数组用于表示连通分量，同时还需要在 Percolation 中维护另一个数组用于表示 site 本身 open / block 的状态。\n同时，两个数组的规模并不相同，原因在于实现过程中为了提高查询是否渗的效率，需要定义虚拟顶部结点 virtual top node 与虚拟底部结点 virtual bottom node ，分别与网格的第一列和最后一列相连。\n同时，题目要求输入的索引范围为 1 \u0026lt;= index \u0026lt;= N，因此，对于索引从零开始的数组而言，还存在一个下标转换的过程。\n通过以上分析，我们定义本题所使用的数据结构如下：\n记录格点 open / block 状态信息 1 boolen[] site = new boolen[N * N]; 由于有大小为 N x N 的网格，定义长度为 N * N 的 boolean 数组存储其状态信息（顶部虚拟格点与尾部虚拟格点不需要存储状态信息）。true 表示为格点处于 open 状态。对于所输入的行与列，对应的索引转化关系如下：\n1 index = (row - 1) * N + col - 1; union-find 算法内部数据结构载体 1 int[] parent = new int[N * N + 2]; 该数组存储的是连通分量的信息，由于我们额外定义了两个虚拟格点，因此数组长度应为 N * N + 2 。同时，规定 0 号位表示虚拟顶部格点，末位即 N * N + 1 号位表示虚拟底部格点。\n对于所输入的行于列，对应的索引转化关系如下：\n1 index = (row - 1) * N + col; 实现细节 Percolation 变量定义 1 2 3 4 5 6 7 8 9 10 11 /* 共查集记录格点的连通信息， 大小定义为 N * N + 2，其中包含 大小为 N * N 的网格与虚拟顶部格点、虚拟底部格点。虚拟顶部 格点使用数组的 0 号位表示，虚拟尾部格点使用最后一位表示， 中间 1 ~ N 位用于表示网格格点所属连通分量 */ private final WeightedQuickUnion weightedQuickUnion; /* 记录格点状态，“true” 表示 “open”，大小为 N * N */ private final boolean[] site; /* 记录网格的尺寸，即数据的规模 */ private final int N; /* 记录网格中状态为 “open” 的格点数目 */ private int openCount; 核心方法定义 构造器：public Percolation(int); 1 2 3 4 5 6 7 8 9 /* 构造器，创建个 N * N 规格的网格，所有格点状态设为 “blocked” */ public Percolation(int N) { // N 不大于 0 则抛出异常 if(N \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34; \\\u0026#34;N\\\u0026#34; must be a positive integer.\u0026#34;); this.N = N; weightedQuickUnion = new WeightedQuickUnion(N * N + 2); site = new boolean[N * N]; } 设定格点状态为 “open” ：public void open(int row, int col); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void open(int row, int col) { // 索引不合法则抛出异常 if(outOfBounds(row, col)) { throw new IndexOutOfBoundsException(); } // 如果已经为 “open” 状态则不做处理 if(isOpen(row, col)) { return; } // “open” 格点在最上层时，与虚拟顶部格点连通 if(row == 1) { weightedQuickUnion.union(0, col); } // “open” 格点在最下层时，与虚拟底部格点连通 if(row == N) { weightedQuickUnion.union(N * N + 1, N * (N - 1) + col); } /* 私有成员方法 connectOpenedSite： 将 “open” 格点与上下左右已经为 “open” 的相邻格点连通 */ connectOpenedSite(row, col); site[(row - 1) * N + col - 1] = true; openCount++; } 检测是否渗出：public boolean percolates(); 1 2 3 public boolean percolates() { return weightedQuickUnion.connected(0, N * N + 1); } PercolationStats 变量定义 1 2 3 4 5 6 /* 记录每轮循环结果的总和值 */ private double sum; /* 进行 T 轮模拟 */ private final int T; /* 长度为 T 的数组，记录每轮模拟的结果 */ private final double[] record; 核心方法定义 构造器 \u0026amp; 进行 T 轮模拟：public PercolationStats(int N, int T); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 对规模为 N 的问题进行 T 轮模拟，记录结果 */ public PercolationStats(int N, int T) { this.T = T; record = new double[T]; Random random = new Random(); for(int i = 0; i \u0026lt; T; i++) { Percolation percolation = new Percolation(N); while(!percolation.percolates()) { // 对于行列，取 1 ~ N 的随机数 int row = random.nextInt(N) + 1; int cul = random.nextInt(N) + 1; percolation.open(row, cul); } record[i] = percolation.getOpenCount() / (double)(N * N); sum += record[i]; } } quick-find 算法 变量定义 1 2 3 4 /* 长度为 N 的数组，作为连通分量信息的载体 */ private final int[] parent; /* 记录连通分量的个数 */ private int count; 核心方法定义 查找位点所在的连通分量：public int find(int index); 1 2 3 4 5 6 7 /* 获取所在的连通分量 */ public int find(int index) { if (index \u0026lt; 0 || index \u0026gt;= parent.length) { throw new IllegalArgumentException(\u0026#34;index \u0026#34; + index + \u0026#34; is not between 0 and \u0026#34; + (parent.length - 1)); } return parent[index]; } 检查是否已经相连：public boolean connected(int p, int q); 1 2 /* 检查是否已经相连 */ public boolean connected(int p, int q) { return find(p) == find(q); } 将格点相连：public void union(int p, int q); 1 2 3 4 5 6 7 8 9 /* 连接两个连通分量 */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) return; for(int i = 0; i \u0026lt; parent.length; i++) if(parent[i] == qRoot) parent[i] = pRoot; count--; } weighted quick-union 算法 变量定义 1 2 3 4 5 6 /* 记录格点的连通分量信息 */ private int[] parent; /* 记录连通分量的树的长度 */ private int[] treeSize; /* 记录连通分量的数量 */ private int count; 核心方法定义 查找位点所在的连通分量：public int find(int index); 1 2 3 4 5 6 7 8 9 /* 获取所在的连通分量 */ public int find(int index) { if (index \u0026lt; 0 || index \u0026gt;= parent.length) { throw new IllegalArgumentException(\u0026#34;index \u0026#34; + index + \u0026#34; is not between 0 and \u0026#34; + (parent.length - 1)); } while(parent[index] != index) index = parent[index]; return index; } 检查是否已经相连：public boolean connected(int p, int q); 1 2 /* 检查是否已经相连 */ public boolean connected(int p, int q) { return find(p) == find(q); } 将格点相连：public void union(int p, int q); 1 2 3 4 5 6 7 8 9 10 11 12 13 /* 连接两个连通分量 */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) return; if(treeSize[pRoot] \u0026gt; treeSize[qRoot]) { parent[pRoot] = qRoot; } else { parent[qRoot] = pRoot; } treeSize[qRoot] += treeSize[pRoot]; count--; } 实验结果 设定 (T, N) = (200, 100), (500, 100), (500, 200) ，\n运行环境：\nOS : Windows 10 (64bit)\nCPU: AMD Ryzen 5 5600U 2.30Ghz\nRAM: 16 GB\n进行多次不同规模大小的实验，得到结果记录如下：\nT N mean stddev confidece 500 50 0.59244800 0.02630281 [0.59014246, 0.59475354] 500 100 0.59265740 0.01491659 [0.59134990, 0.59396490] 500 200 0.59235685 0.00961121 [0.59151439, 0.59319931] 500 300 0.59255369 0.00764554 [0.59188353, 0.59322385] 依据多次运行结果，有理由认为，*p 的近似值位于 0.591 ~ 0.593 之间。\n五、复杂度分析 用实验表明两种算法所实现的 Percolation 类型当N加倍时对运行时间的影响 Weighted Quick Union 算法 与 Quick Find 算法 执行时间对比 比较 Weighted Quick Union 算法 与 Quick Find 算法 在面向不同数据规模时所执行的时间差距。（单位：ms）\nT N QuickFind WeightedQucikUnion 50 10 15 8 50 20 32 16 50 40 93 47 50 80 818 113 50 160 12865 626 50 320 192214 5162 50 640 TLE 49738 可以看到，两种算法在面对较大规模的数据时，执行时间开销上面有相当大的差别。\n复杂度分析 通过 quick-find 算法 实现 时间复杂度 O(TN2) 空间复杂度 O(N2) 通过 weighted quick-union 算法 实现 时间复杂度 O(TNlogN) 空间复杂度 O(N2) 收获感想 利用并查集寻找连通分量的思路，十分简洁且有效。通过使用两种不同的 union-find 算法解决渗透问题，让我体会到了不同算法间的性能差距。 从 quick find 算法 不断改进，直到效率更高的 weighted qiuck union 算法 ，每一个小改动都能带来性能上的提升。算法设计的确是一件非常有趣且相当有用的的事情。\n完整程序 Quick Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package UnionFind; import java.util.Random; /** * @author wang yuxuan * @create 2021.10.02 */ public class QuickFind { /* record information of connected components */ private final int[] parent; /* record count of connected components */ private int count; /* constructor and initialization */ public QuickFind(int N) { this.parent = new int[N]; this.count = N; for(int i = 0; i \u0026lt; parent.length; i++) { parent[i] = i; } } /* get the connected component of the point with index */ public int find(int index) { if (index \u0026lt; 0 || index \u0026gt;= parent.length) { throw new IllegalArgumentException(\u0026#34;index \u0026#34; + index + \u0026#34; is not between 0 and \u0026#34; + (parent.length - 1)); } return parent[index]; } /* whether double points belong to a same component */ public boolean connected(int p, int q) { return find(p) == find(q); } /* connect two component */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) return; for(int i = 0; i \u0026lt; parent.length; i++) { if(parent[i] == qRoot) parent[i] = pRoot; } count--; } /* get count */ public int count() { return this.count; } public static void main(String[] args) { int N = 50; QuickFind uf = new QuickFind(N); for(int i = 0; i \u0026lt; 10; i++) { Random random = new Random(); int p = random.nextInt(N); int q = random.nextInt(N); uf.union(p, q); } System.out.println(uf.count); } } Weighted Quick Union 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package UnionFind; import java.util.Random; /** * @author wang yuxuan * @create 2021.10.02 */ public class QuickFind { /* record information of connected components */ private final int[] parent; /* record count of connected components */ private int count; /* constructor and initialization */ public QuickFind(int N) { this.parent = new int[N]; this.count = N; for(int i = 0; i \u0026lt; parent.length; i++) { parent[i] = i; } } /* get the connected component of the point with index */ public int find(int index) { if (index \u0026lt; 0 || index \u0026gt;= parent.length) { throw new IllegalArgumentException(\u0026#34;index \u0026#34; + index + \u0026#34; is not between 0 and \u0026#34; + (parent.length - 1)); } return parent[index]; } /* whether double points belong to a same component */ public boolean connected(int p, int q) { return find(p) == find(q); } /* connect two component */ public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) return; for(int i = 0; i \u0026lt; parent.length; i++) { if(parent[i] == qRoot) parent[i] = pRoot; } count--; } /* get count */ public int count() { return this.count; } public static void main(String[] args) { int N = 50; QuickFind uf = new QuickFind(N); for(int i = 0; i \u0026lt; 10; i++) { Random random = new Random(); int p = random.nextInt(N); int q = random.nextInt(N); uf.union(p, q); } System.out.println(uf.count); } } Penetration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 package PenetrationTest; import UnionFind.*; import java.util.Random; /** * @author wang yuxuan * @create 2021.10.02 */ public class Percolation { /* record the information of connected components with N * N + 2 0 represents the virtual top node, and N * N - 1 represents the virtual bottom node */ private final WeightedQuickUnion weightedQuickUnion; /* record the site is opened or not */ private final boolean[] site; /* record the size of the network */ private final int N; /* record the numbers of opened site */ private int openCount; /* whether the index is out of bounds */ private boolean outOfBounds(int row, int col) { return row \u0026gt; N || row \u0026lt; 1 || col \u0026gt; N || col \u0026lt; 1; } /* union the opened sites in the up, down, left and right */ private void connectOpenedSite(int row, int col) { if(!outOfBounds(row, col + 1) \u0026amp;\u0026amp; isOpen(row, col + 1)) { weightedQuickUnion.union((row - 1) * N + col, (row - 1) * N + col + 1); } if(!outOfBounds(row, col - 1) \u0026amp;\u0026amp; isOpen(row, col - 1)) { weightedQuickUnion.union((row - 1) * N + col, (row - 1) * N + col - 1); } if(!outOfBounds(row + 1, col) \u0026amp;\u0026amp; isOpen(row + 1, col)) { weightedQuickUnion.union((row - 1) * N + col, row * N + col); } if(!outOfBounds(row - 1, col) \u0026amp;\u0026amp; isOpen(row - 1, col)) { weightedQuickUnion.union((row - 1) * N + col, (row - 2) * N + col); } } /* create N-by-N grid, with all sites blocked */ public Percolation(int N) { if(N \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34; \\\u0026#34;N\\\u0026#34; must be a positive integer.\u0026#34;); this.N = N; weightedQuickUnion = new WeightedQuickUnion(N * N + 2); site = new boolean[N * N]; } /* open site (row i, column j) if it is not already */ public void open(int row, int col) { if(outOfBounds(row, col)) { throw new IndexOutOfBoundsException(); } if(isOpen(row, col)) { return; } if(row == 1) { weightedQuickUnion.union(0, col); } if(row == N) { weightedQuickUnion.union(N * N + 1, N * (N - 1) + col); } connectOpenedSite(row, col); site[(row - 1) * N + col - 1] = true; openCount++; } /* return is site (row i, column j) opened */ public boolean isOpen(int row, int col) { return site[(row - 1) * N + col - 1]; } /* return is site (row i, column j) full */ public boolean isFull(int row, int col) { return weightedQuickUnion.connected(0, (row - 1) * N + col); } /* return does the system percolate */ public boolean percolates() { return weightedQuickUnion.connected(0, N * N + 1); } /* get numbers of opened site */ public int getOpenCount() { return openCount; } /* test client, optional */ public static void main(String[] args) { int N = 100; Percolation percolation = new Percolation(N); Random random = new Random(); int row, cul; double p; while(!percolation.percolates()) { row = random.nextInt(N) + 1; cul = random.nextInt(N) + 1; percolation.open(row, cul); // System.out.println(percolation.getOpenCount()); } p = percolation.getOpenCount() / (double)(N * N); System.out.println(p); } } PenetrationStats 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package PenetrationTest; import java.util.Random; import java.util.Scanner; import static java.lang.Math.sqrt; /** * @author wang yuxuan * @create 2021.10.02 */ public class PercolationStats { /* the sum of record[] */ private double sum; /* times */ private final int T; /* record the result */ private final double[] record; /* perform T independent computational experiments */ public PercolationStats(int N, int T) { if(N \u0026lt;= 0 || T \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34;\\\u0026#34;N\\\u0026#34; and \\\u0026#34;T\\\u0026#34; must be a positive integer. \u0026#34;); this.T = T; record = new double[T]; Random random = new Random(); for(int i = 0; i \u0026lt; T; i++) { Percolation percolation = new Percolation(N); while(!percolation.percolates()) { int row = random.nextInt(N) + 1; int cul = random.nextInt(N) + 1; percolation.open(row, cul); } record[i] = percolation.getOpenCount() / (double)(N * N); sum += record[i]; } } /* sample mean of percolation threshold */ public double mean() { return sum / (double) T; } /* sample standard deviation of percolation threshold */ public double stddev() { double standardDeviation = 0; double mean = mean(); for(double xt : record) { standardDeviation += (xt - mean) * (xt - mean); } standardDeviation /= (T - 1); standardDeviation = sqrt(standardDeviation); return standardDeviation; } /* returns lower bound of the 95% confidence interval */ public double confidenceLo() { return mean() - 1.96 * stddev() / sqrt((double) T); } /* returns upper bound of the 95% confidence interval */ public double confidenceHi() { return mean() + 1.96 * stddev() / sqrt((double) T); } public static void main(String[] args) { System.out.println(\u0026#34;Enter \\\u0026#34;T\\\u0026#34; and \\\u0026#34;N\\\u0026#34; :\u0026#34;); Scanner in = new Scanner(System.in); int T = 500; int N = in.nextInt(); /* record program running time */ long start = System.currentTimeMillis(); PercolationStats stats = new PercolationStats(N, T); long end = System.currentTimeMillis(); System.out.println(\u0026#34;T = \u0026#34; + T + \u0026#34;, N = \u0026#34; + N + \u0026#34;, running time: \u0026#34; + (end - start) + \u0026#34;ms\u0026#34;); System.out.println(\u0026#34;Result: \u0026#34;); System.out.println(\u0026#34;mean: \u0026#34; + String.format(\u0026#34;%.8f\u0026#34;, stats.mean())); System.out.println(\u0026#34;stddev: \u0026#34; + String.format(\u0026#34;%.8f\u0026#34;, stats.stddev())); System.out.println(\u0026#34;confidence: [\u0026#34; + String.format(\u0026#34;%.8f\u0026#34;, stats.confidenceLo()) + \u0026#34;, \u0026#34; + String.format(\u0026#34;%.8f\u0026#34;, stats.confidenceHi()) + \u0026#34;]\u0026#34;); } } ","date":"2021-12-23T16:12:52Z","image":"https://TuJin07.github.io/p/%E6%B8%97%E9%80%8F%E9%97%AE%E9%A2%98percolation/cover_hu312e2770b834f6abc1b8e3d7400af482_1303151_120x120_fill_q75_box_smart1.JPG","permalink":"https://TuJin07.github.io/p/%E6%B8%97%E9%80%8F%E9%97%AE%E9%A2%98percolation/","title":"渗透问题(Percolation)"}]